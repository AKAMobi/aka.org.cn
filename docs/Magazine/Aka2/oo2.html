<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>OO，OO以后，及其极限&lt;2&gt;</title>
</head>

<body>
<div align="center"><center>

<table border="0" width="630">
  <tr>
    <td bgcolor="#EEEDB7"><h1 align="center">OO，OO以后，及其极限&lt;2&gt;</h1>
    <h1 align="center"><a href="cover.html"><font size="2">[返回]</font></a></h1>
    <h2 align="center"><br>
    5. OO之后是什么？</h2>
    <p><br>
    　　通过上节的讨论我们了解了维特根斯坦在《逻辑哲学论》一书中提出的OO的思想。即存在如下的认识链： 
    世界 → 事实 → 原子事实 → 对象(object)。本节我们讨论OO之后是什么这个问题。我们将从历史的和逻辑的角度来进行推理，看看能得出什么样的结论。<br>
    <br>
    　　<strong>一、 从软件工程的发展历史来看</strong></p>
    <p>　　1969年NATO会议之后，“软件危机”成为人们关注的焦点。为迎接软件危机的挑战，人们进行了不懈的努力。这些努力大致上是沿着两个方向同时进行的。一是从管理的角度，希望实现软件开发过程的工程化。这方面最为著名的成果就是提出了大家都很熟悉的“瀑布式”生命周期模型。它是在60年代末“软件危机”后出现的第一个生命周期模型。如下所示。<br>
    <br>
    　　分析 → 设计 → 编码 → 测试 → 维护<br>
    <br>
    　　后来，又有人针对该模型的不足，提出了快速原型法、螺旋模型、喷泉模型等对“瀑布式”生命周期模型进行补充。现在，它们在软件开发的实践中被广泛采用。<br>
    <br>
    　　这方面的努力，还使人们认识到了文档的标准以及开发者之间、开发者与用户之间的交流方式的重要性。一些重要文档格式的标准被确定下来，包括变量、符号的命名规则以及原代码的规范格式。<br>
    <br>
    　　值得一提的是，在开发者之间、开发者与用户之间的交流方式这方面，由于Internet的出现提供了一种全新的交流手段，也产生了一种基于Internet的全新的开发方式，即OSS(Open 
    Source Software)。 其代表作有Linux(操作系统)，Apeche(web server)，Sendmail(Mail 
    server)等。OSS是一种极有前途的开发方式，借Internet发展的大潮，它势必会对整个软件开发模型产生难以估量的影响。近期的IEEE软件工程专刊将为次出一期专题特刊。1999年1月份也将举行关于Linux/OSS的国际研讨会。各家计算机公司纷纷对此作出反应，微软也意识到了来自OSS的巨大威胁，在8月底提出了一份内部保密的文件，专门提出了自己的应对策略，可谓是山雨欲来风满楼。有兴趣者请对此保持关注。<br>
    <br>
    　　软件工程发展的第二个方向，侧重与对软件开发过程中分析、设计的方法的研究。这方面的第一个重要成果就是在70年代风靡一时的结构化开发方法，即PO（面向过程的开发或结构话方法）。 
    PO是人们在用计算机世界来表达现实世界时，追求过程话、模块化、封装以及更高的抽象的结果。 
    人们用计算机来映射现实世界时，最低层的实现无非是靠数字电路技术产生的高电平与低电平信号。用数学的语言来表示，就是像　010101000010111 
    这样的二进制串。这样的抽象层次是极低的，远离了自然语言，对一般人是不可理解的。人们把这些二进制串分块定义，提出了字节、ASCII码这样的更高抽象层次的概念，使之对应于自然语言的一个个字母。在此基础再借助某种形式语言，抽象出变量、表达式、运算、语句等概念。在这个层面上，一般经过训练的程序员已经可以比较不那么痛苦地进行软件开发了。下一步的抽象就产生了PO。 
    在PO中，人们关注的是如何用函数和过程来实现对现实世界的模拟，将其映射到计算机世界之中。 
    OO是这种抽象层次不断提高的过程的自然发展结果，它采用类和对象的概念，把变量以及对变量进行操作的函数和过程封装在一起，用这种更高一级的抽象来表达客观世界。通常，一个对象包含一些属性和方法，它对应于自然语言中一个有意义的名词，描述了现实世界中的一个物体（物理实体）或概念（抽象实体）。 
    这个抽象层次如下图所示：<br>
    <br>
    　　计算机世界中的抽象层次<br>
    <br>
    　　＊XO(X?-Oriented） 最高的抽象层次<br>
    　　＊OO(对象、类)<br>
    　　＊PO(过程、函数、变量)<br>
    　　＊变量、运算、表达式、语句<br>
    　　＊字节(4位、8位、16位、32位、64位)<br>
    　　＊二进制串 0101011110001 最低的抽象层次<br>
    <br>
    　　从上图及以上的讨论我们知道，软件工程的发展历史就是人们不断追求更高的抽象、封装和模块化的历史。OO当然不会是历史的终结。尽管不能精确得到OO之后是什么，我们至少可以推知，OO之后的XO，必然将是比OO更高一级的抽象。它所依赖的核心概念必然高于并包容对象这一概念。正如对象高于并包容了函数和变量一样。<br>
    <br>
    <br>
    　　<strong>二、 从维特根斯坦在《逻辑哲学论》一书中的思想来看</strong> 
    <br>
    <br>
    　　前面我们已经知道，维特根斯坦在《逻辑哲学论》 
    一书中提出了如下思想：<br>
    <br>
    　　＊世界可以分解为事实 ( The world divides into facts.)<br>
    　　＊事实是由原子事实(atomic facts)组成的。<br>
    　　＊一个原子事实是多个对象(objects)的组合。 <br>
    　　＊对象是简单的(基本的) The Object is simple。<br>
    　　＊对象形成了世界的基础。 <br>
    <br>
    　　即： 世界---事实----原子事实----对象这样一个从整体到局部、从抽象到具体的认识之链。在这个层次中，对象作为最基本的模块，构成了整个认识大厦的基石。对象通过相互之间的复杂的关联构成了整个世界。这个观点也是面向对象理论的基石。<br>
    <br>
    　　上一段我们通过对计算机世界的分析得出，OO之后的发展，必将产生比OO更高一级的抽象的概念用于编程。按照维特根斯坦的思想可以很自然地得出结论：这个概念就是事实(FACT)。即面向对象之后是面向事实，OO之后是<font
    color="#FF8000"><u><big><big>FO</big></big></u></font>（<font color="#FF8000"><u><big><big>Fact-Oriented</big></big></u></font>）。<br>
    <br>
    　　那么，什么是事实(fact)？让我们再次重温一下维特根斯坦的观点。<br>
    <br>
    　　首先，世界是所有事实的总和。世界可以分解为事实。任一事实或者为真，或者不为真。（即事实应返回一个布尔变量，或为TRUE，或为FALSE）<br>
    　　其次，那些为真的事实，是由原子事实(atomic facts)组成的。<br>
    　　原子事实和简单对象的关系是这样的：一个原子事实是多个对象(object)的组合。在原子事实中，对象以某种确定的方式相连。原子事实中对象相互连接的方式即是原子事实的结构。 
    也就是说，原子事实是有结构的，这种结构被维特根斯坦看作是现实世界的模式(form)。<br>
    <br>
    　　这里，维特根斯坦提出了几个重要的概念：事实(fact)、原子事实(atomic 
    fact)和模式(form)。<br>
    <br>
    　　如果我们以上的推理过程正确的话，我们将得出一个结论：面向对象(OO)之后是面向事实(FO)，在面向事实(FO)的分析、设计和编程中，我们将主要围绕事实(fact)、原子事实(atomic 
    fact)和模式(form)这些基本概念来组织我们的软件开发活动。在人们认识世界的层次结构中，这些概念是比对象(object)和类(class)更高一级的抽象。<br>
    </p>
    <h2 align="center">6. 最后的极限<br>
    </h2>
    <p>　　OO之后如果FO，那么我们当然要问，FO之后又是什么？再往后哪？有没有一个最后的极限？若有，极限何在？这是个很困难的问题，不过还是让我们继续思考下去，看看能有些什么结果，尽管它可能会是十分愚蠢和幼稚。<br>
    <br>
    　　我们知道，软件的实质是人们以计算机编程语言为桥梁，将客观感知世界映射于计算机世界中去，以解决人们在客观感知世界中要解决的问题。这里牵涉三个主要的范畴：<br>
    <br>
    　　客观感知世界--------计算机编程语言----------计算机世界<br>
    <br>
    　　(1)<u>计算机世界</u><br>
    <br>
    　　在计算机世界中，可以想象的是，单位面积的一块芯片上可以集成的晶体管数目总会有个上限，摩尔定律早晚要失效。另外，现在多数电脑采用的冯.诺依曼结构也需要被突破。（如并行计算的研究）<br>
    <br>
    　　(2)<u>计算机编程语言</u><br>
    <br>
    　　现在的计算机编程语言，都是某种类型的形式语言。要解决一个问题，首先我们必须为它构造算法。也就是说，对于没有算法的问题，我们是束手无策的。这类问题被成为是“不可计算的”。它们的解不能由图灵机来产生。这是我们面临的一个极限。<br>
    <br>
    　　那么一个问题有了算法，是不是就一定可以解决哪？很遗憾，答案是不。对于那些NP（非多项式）问题，尤其是NP完备的问题，尽管存在算法，我们仍然是无法在多项式时间内解决的。著名的“哈密顿线路问题”和“旅行推销员问题”都属于这类问题。它们的共同特征是，当问题的规模（或复杂度）线形增加时，解决该问题所要化的时间将呈指数上升，以至于它们尽管理论上是可求解的，但实际上却是不可能的。因为要花费的时间可能已经超过了宇宙的寿命。这也是我们面临的一个极限。<br>
    <br>
    　　还需要指出，现在的计算机语言作为形式语言的一种，也必然具有形式语言自身所有的局限性。数学的发展史上，曾经有三次危机，第三次危机是有罗素的一个“佯谬”引发的悖论危机。为解决此危机，希尔伯特提出了宏伟的形式化规划，企图使数学一劳永逸地处于无可争辩的安全基础之上。可是，1931年奥地利25岁的天才数学逻辑学家歌德尔提出了一条划时代的定理，粉碎了希尔伯特形式化的美梦。哥德尔定理向我们展示，公理系统本身的协调性的陈述在被编码成适当的算术命题后，将成为一道这样“不能决定的”不能决定的命题。想象一个表达式既不为真，也不为假，它的真假对一个形式系统（计算机）而言它是不可判定的。因此在这方面，哥德尔定理是我们面临的又一个极限。<br>
    <br>
    　　(3)<u>客观感知世界</u><br>
    <br>
    　　现在让我们假设软件工程已经发展到了这样一个理想的境界，有一天我们实现了自然语言编程，是否就万事大吉了？换句话，自然语言是否能很好地描述、表达客观感知世界？<br>
    <br>
    　　维特根斯坦在《逻辑哲学论》里已经指出了。<br>
    <br>
    　　＊世界的意义必定存在于世界之外；<br>
    　　＊显然伦理学是无法表述的。 伦理学是超越现实的；<br>
    　　＊实际上存在着不可表达的东西；这显示了它的存在；它是神秘的。<br>
    　　（见《逻辑哲学论》第六节）<br>
    <br>
    　　也就是说，外部世界中存在一些我们可以感知却无法用语言来表达的东西。<br>
    <br>
    　　他接着说：<br>
    　　“对于那些不可言说的，必须保持沉默。”（Whereof one cannot speak，thereof 
    one must be silent）<br>
    <br>
    　　这句话，成为我们最后的极限。<br>
    <br>
    　　在讨论完这三个范畴中我们将面临的主要问题后，我们最后来讨论一下人的主观世界对软件及软件开发的影响。<br>
    </p>
    <h2 align="center">7. 极限之外的空间</h2>
    <p><br>
    　　世界可以分为主观想象世界和客观可感知世界，或者说是内世界和外世界。其中，主观想象世界是计算机从未涉足的空间。这是属于我们个人的私有空间，充斥着我们自己离奇古怪的幻想和起伏不定的情绪。它具有极大的跳跃性和不确定性，常常以直觉、想象的方式进行着自己的活动。它们通常是语言所不能表达的。<br>
    <br>
    　　尽管这个内世界是如此的复杂、混乱、难以捉摸，但它却是我们与生俱来的一部分。<br>
    <br>
    　　我们就是这样的人。<br>
    <br>
    　　就是这样的人从事着软件开发的工作。<br>
    <br>
    　　这样的人开发出来的软件究竟在多大程度上是对客观世界不折不扣的映射？还是这个映射过程已经被扭曲或掺杂了？软件开发者的这个主观想象世界，他们的欢乐、沮丧、奇想、恐惧、希望等等，究竟是怎样影响着软件开发的质量？<br>
    <br>
    　　人们是要用计算机来复制整个世界？还是来复制人本身？<br>
    　　人们是在扮演上帝的角色吗？<br>
    <br>
    　　这样的问题我实在不知该如何去解答，甚至觉得根本无从下手。<br>
    <br>
    　　如果你还有足够的耐心读到这里，请你也来想一想，希望它们不会使你头疼。<br>
    <br>
    　　:)<br>
    <br>
    　　最后，我将引用我从网上偶尔发现的一篇文章中的话作为结束语：<br>
    <br>
    　　<font color="#004080">“自以为是的立法者(人类)犯下了一个大错，以为自己能定义整个软件开发过程。他们既不了解其开始也不了解其结果。学术界试了一下，然后就知难而退了。商业界则对其毫无办法。大型软件开发商们斥巨资来制造代码，明明想要扮演上帝的角色，却还装作自己是人类的公仆。所有人都在盯着镜子里的自己。计算机却在一旁偷偷的笑。”</font><br>
    <br>
    <font color="#004080">　　“ The self-righteous，legalists have made a big mistake in 
    thinking they can define the software development process. They understand neither its 
    beginnings or its consequences. The academic community tried it briefly and then gave up. 
    The business community never cracked the code. The giant software houses are pouring 
    enormous energy into process of creating code，playing God，and pretending to be 
    servants of mankind. All are looking at themselves in the mirror. The computer is laughing 
    back.” <br>
    </font><br>
    ----《完》----<br>
    </p>
    <hr>
    <h3>后记： </h3>
    <p>　　大概4月份的时候，开始写这个题目，一口气写了4篇，贴到水母清华的软工板上。后来主要因为懒，就停了下来。多亏有几位网友来信催促和鼓励，才使我有机会逼自己坐下来完成最后的3篇。这里特向他们表示感谢！ 
    尤其要感谢seraph和xiaobo。<br>
    <br>
    　　看屏幕上的字的确是件累人的事，所以如果你竟然有耐性看到了这里，我一定要向你表示佩服了。 
    :)<br>
    <br>
    　　最后说明，本文不是一个正式版，只是一个学习和思考的心得体会，行文仓促，也没有仔对照细修改。文中的错误和不恰当的翻译均由我全部负责，欢迎指正。</p>
    <hr>
    <p align="right">AKA的waterbird<br>
    1998年10月7日0点29分</p>
    <p align="center"><a href="cover.html"><font size="2">[返回]</font></a></td>
  </tr>
</table>
</center></div>
</body>
</html>
