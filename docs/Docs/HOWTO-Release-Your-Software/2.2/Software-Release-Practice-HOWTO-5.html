<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Software Release Practice HOWTO: Good development practice</TITLE>
 <LINK HREF="Software-Release-Practice-HOWTO-6.html" REL=next>
 <LINK HREF="Software-Release-Practice-HOWTO-4.html" REL=previous>
 <LINK HREF="Software-Release-Practice-HOWTO.html#toc5" REL=contents>
</HEAD>
<BODY>
<A HREF="Software-Release-Practice-HOWTO-6.html">Next</A>
<A HREF="Software-Release-Practice-HOWTO-4.html">Previous</A>
<A HREF="Software-Release-Practice-HOWTO.html#toc5">Contents</A>
<HR>
<H2><A NAME="s5">5. Good development practice</A></H2>

<P>Most of these are concerned with ensuring portability, not only across
Linuxes but to other Unixes as well.  Being portable to other Unixes 
is not just a worthy form of professionalism and hackerly politeness, 
it's valuable insurance against future changes in Linux itself.
<P>Finally, other people <EM>will</EM> try to build your code on non-Linux
systems; portability minimizes the number of annoying perplexed email
messages you will get.
<P>
<H2><A NAME="ss5.1">5.1 Write either pure ANSI C or a portable scripting language</A>
</H2>

<P>For portability and stability, you should write either in ANSI C or a
scripting language that is guaranteed portable because it has just one
cross-platform implementation.
<P>Scripting languages that qualify include Python, Perl, Tcl, and Emacs Lisp.
Plain old shell does <EM>not</EM> qualify; there are too many different
implementations with subtle idiosyncracies, and the shell environment
is subject to disruption by user customizations such as shell aliases.
<P>Java holds promise as a portable language, but the Linux-available 
implementations are still scratchy and poorly integrated with Linux.
Java is still a bleeding-edge choice, though one likely to become more
popular as it matures.
<P>
<H2><A NAME="ss5.2">5.2 Follow good C portability practices</A>
</H2>

<P>If you are writing C, do feel free to use the full ANSI features --
including function prototypes, which will help you spot cross-module
inconsistancies.  The old-style K&amp;R compilers are history.
<P>On the other hand, do <EM>not</EM> assume that GCC-specific 
features such as the `-pipe' option or nested functions are available.
These will come around and bite you the second somebody ports to a
non-Linux, non-GCC system.
<P>
<H2><A NAME="ss5.3">5.3 Use autoconf/automake/autoheader</A>
</H2>

<P>If you're writing C, use autoconf/automake/autoheader to handle portability
issues, do system-configuration probes, and tailor your makefiles.  People
building from sources today expect to be able to type "configure; make"
and get a clean build -- and rightly so.
<P>
<H2><A NAME="ss5.4">5.4 Sanity-check your code before release</A>
</H2>

<P>If you're writing C, test-compile with -Wall and clean up the errors at
least once before each release.  This catches a surprising number of
errors.  For real thoroughness, compile with -pedantic as well.
<P>If you're writing Perl, check your code with perl -c (and maybe -T, if
applicable).  Use perl -w and 'use strict' religiously.  (See the Perl
documentation for discussion.)
<P>
<H2><A NAME="ss5.5">5.5 Sanity-check your documentation and READMEs before release</A>
</H2>

<P>Run a spell-checker on them.  If you look like you can't spell and
don't care, pleople will assume you code is sloppy and careless too.
<P>
<HR>
<A HREF="Software-Release-Practice-HOWTO-6.html">Next</A>
<A HREF="Software-Release-Practice-HOWTO-4.html">Previous</A>
<A HREF="Software-Release-Practice-HOWTO.html#toc5">Contents</A>
</BODY>
</HTML>
