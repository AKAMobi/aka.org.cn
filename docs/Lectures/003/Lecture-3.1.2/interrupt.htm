<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb_2312-80">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>硬件中断概述</TITLE>
</HEAD>
<BODY>

<B><FONT FACE="宋体" LANG="ZH-CN" SIZE=6><P ALIGN="CENTER">硬件中断</P>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=5><P ALIGN="JUSTIFY">硬件中断概述</P>
</B></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">中断可以用下面的流程来表示</FONT><FONT FACE="Courier New" SIZE=3>:</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">中断产生源</FONT><FONT FACE="Courier New" SIZE=3> --&gt; </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中断向量表</FONT><FONT FACE="Courier New" SIZE=3> (idt) --&gt; </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中断入口</FONT><FONT FACE="Courier New" SIZE=3> ( </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>一般简单处理后调用相应的函数</FONT><FONT FACE="Courier New" SIZE=3>) ---&gt;do_IRQ--&gt; </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>后续处理</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>软中断等工作</FONT><FONT FACE="Courier New" SIZE=3>)</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">如图</FONT><FONT FACE="Courier New" SIZE=3>:</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><IMG SRC="Image1.jpg" WIDTH=553 HEIGHT=344>具体地说，处理过程如下</FONT><FONT FACE="Courier New" SIZE=3>:</P>
<P ALIGN="JUSTIFY"></P>
<OL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>中断信号由外部设备发送到中断芯片</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>模块</FONT><FONT FACE="Courier New" SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的引脚</LI></P>
<P ALIGN="JUSTIFY"><LI>中断芯片将引脚的信号转换成数字信号传给</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，例如</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>主芯片引脚</FONT><FONT FACE="Courier New" SIZE=3>0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>发送的是</FONT><FONT FACE="Courier New" SIZE=3>0x20</LI></P>
<P ALIGN="JUSTIFY"><LI>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>接收中断后，到中断向量表</FONT><FONT FACE="Courier New" SIZE=3>IDT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中找中断向量</LI></P>
<P ALIGN="JUSTIFY"><LI>根据存在中断向量中的数值找到向量入口</LI></P>
<P ALIGN="JUSTIFY"><LI>由向量入口跳转到一个统一的处理函数</FONT><FONT FACE="Courier New" SIZE=3>do_IRQ</LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>在</FONT><FONT FACE="Courier New" SIZE=3>do_IRQ</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中可能会标注一些软中断，在执行完</FONT><FONT FACE="Courier New" SIZE=3>do_IRQ</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>后执行这些软中断。</LI></P></OL>

<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">下面一一介绍。</P>
</FONT><B><FONT FACE="黑体" LANG="ZH-CN" SIZE=5><P ALIGN="JUSTIFY">　</P>
</FONT><FONT FACE="Courier New" SIZE=5><P ALIGN="JUSTIFY">8259</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=5>芯片</P>
</B></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">本文主要参考周明德《微型计算机系统原理及应用》和</FONT><FONT FACE="Courier New" SIZE=3>billpan</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的相关帖子</P>
<P ALIGN="JUSTIFY"><IMG SRC="Image2.jpg" WIDTH=553 HEIGHT=511></P>
</FONT><B><FONT FACE="Courier New" SIZE=4><P ALIGN="JUSTIFY">1.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=4>中断产生过程</FONT><FONT FACE="Courier New" SIZE=4> </P>
</B></FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">(1)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果</FONT><FONT FACE="Courier New" SIZE=3>IR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>引脚上有信号，会使中断请求寄存器</FONT><FONT FACE="Courier New" SIZE=3>(Interrupt Request Register,IRR)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>相应的位置位，比如图中</FONT><FONT FACE="Courier New" SIZE=3>, IR3, IR4, IR5</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上有信号，那么</FONT><FONT FACE="Courier New" SIZE=3>IRR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT FACE="Courier New" SIZE=3>3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，</FONT><FONT FACE="Courier New" SIZE=3>4</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，</FONT><FONT FACE="Courier New" SIZE=3>5</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为</FONT><FONT FACE="Courier New" SIZE=3>1</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(2)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果这些</FONT><FONT FACE="Courier New" SIZE=3>IRR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中有一个是允许的，也就是没有被屏蔽，那么就会通过</FONT><FONT FACE="Courier New" SIZE=3>INT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>向</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>发出中断请求信号。屏蔽是由中断屏蔽寄存器</FONT><FONT FACE="Courier New" SIZE=3>(Interrupt Mask Register,IMR)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来控制的，比如图中位</FONT><FONT FACE="Courier New" SIZE=3>3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>被置</FONT><FONT FACE="Courier New" SIZE=3>1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，也就是</FONT><FONT FACE="Courier New" SIZE=3>IRR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位</FONT><FONT FACE="Courier New" SIZE=3>3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的信号被屏蔽了。在图中，还有</FONT><FONT FACE="Courier New" SIZE=3>4</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，</FONT><FONT FACE="Courier New" SIZE=3>5</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的信号没有被屏蔽，所以，会向</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>发出请求信号。</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">(3)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>处于开中断状态，那么在执行指令的最后一个周期，在</FONT><FONT FACE="Courier New" SIZE=3>INTA</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上做出回应</FONT><FONT FACE="Courier New" SIZE=3>,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>并且关中断</FONT><FONT FACE="Courier New" SIZE=3>.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(4)8259A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>收到回应后，将中断服务寄存器</FONT><FONT FACE="Courier New" SIZE=3>(In-Service Register)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>置位</FONT><FONT FACE="Courier New" SIZE=3>,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>而将相应的</FONT><FONT FACE="Courier New" SIZE=3>IRR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>复位：</P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>芯片会比较</FONT><FONT FACE="Courier New" SIZE=3>IRR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的中断的优先级，如上图中，由于</FONT><FONT FACE="Courier New" SIZE=3>IMR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中位</FONT><FONT FACE="Courier New" SIZE=3>3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>处于屏蔽状态，所以实际上只是比较</FONT><FONT FACE="Courier New" SIZE=3>IR4,I5,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>缺省情况下，</FONT><FONT FACE="Courier New" SIZE=3>IR0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>最高，依次往下，</FONT><FONT FACE="Courier New" SIZE=3>IR7</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>最低</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这种优先级可以被设置</FONT><FONT FACE="Courier New" SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，所以上图中，</FONT><FONT FACE="Courier New" SIZE=3>ISR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>被设置为</FONT><FONT FACE="Courier New" SIZE=3>4.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(5)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>发出下一个</FONT><FONT FACE="Courier New" SIZE=3>INTA</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>信号时，</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>将中断号送到数据线上，从而能被</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>接收到，这里有个问题：比如在上图中，</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>获得的是数</FONT><FONT FACE="Courier New" SIZE=3>4,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>但是</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>需要的是中断号</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>并不为</FONT><FONT FACE="Courier New" SIZE=3>4)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，从而可以到</FONT><FONT FACE="Courier New" SIZE=3>idt</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>找相应的向量。所以有一个从</FONT><FONT FACE="Courier New" SIZE=3>ISR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的信号到中断号的转换。在</FONT><FONT FACE="Courier New" SIZE=3>Linux</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的设置中，</FONT><FONT FACE="Courier New" SIZE=3>4</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对应的中断号是</FONT><FONT FACE="Courier New" SIZE=3>0x24.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(6)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>处于自动结束中断</FONT><FONT FACE="Courier New" SIZE=3>(Automatic End of Interrupt AEOI)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>状态，那么在刚才那个</FONT><FONT FACE="Courier New" SIZE=3>INTA</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>信号结束前，</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT FACE="Courier New" SIZE=3>ISR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>复位</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>也就是清</FONT><FONT FACE="Courier New" SIZE=3>0),</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果不处于这个状态，那么直到</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>发出</FONT><FONT FACE="Courier New" SIZE=3>EOI</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指令，它才会使得</FONT><FONT FACE="Courier New" SIZE=3>ISR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>复位。</P>
<P ALIGN="JUSTIFY">　</P>
</FONT><B><FONT FACE="Courier New" SIZE=4><P ALIGN="JUSTIFY">2.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=4>一些相关专题</P>
</B></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P><DIR>

</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">(1)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>从</FONT><FONT FACE="Courier New" SIZE=3>8259</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在</FONT><FONT FACE="Courier New" SIZE=3>x86</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>单</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的机器上采用两个</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>芯片，主芯片如上图所示，</FONT><FONT FACE="Courier New" SIZE=3>x86</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>模式规定</FONT><FONT FACE="Courier New" SIZE=3>,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>从</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>将它的</FONT><FONT FACE="Courier New" SIZE=3>INT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>脚与主</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT FACE="Courier New" SIZE=3>IR2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>相连，这样，如果从</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>芯片的引脚</FONT><FONT FACE="Courier New" SIZE=3>IR8-IR15</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上有中断，那么会在</FONT><FONT FACE="Courier New" SIZE=3>INT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上产生信号，主</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT FACE="Courier New" SIZE=3>IR2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上产生了一个硬件信号，当它如上面的步骤处理后将</FONT><FONT FACE="Courier New" SIZE=3>IR2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的中断传送给</FONT><FONT FACE="Courier New" SIZE=3>CPU,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>收到应答后，会通过</FONT><FONT FACE="Courier New" SIZE=3>CAS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>通知从</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>芯片，从</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>芯片将</FONT><FONT FACE="Courier New" SIZE=3>IRQ</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中断号送到数据线上，从而被</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>接收。</P></DIR>

<P ALIGN="JUSTIFY">由此，我猜测它产生的所有中断在主</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上优先级为</FONT><FONT FACE="Courier New" SIZE=3>2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，不知道对不对。</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">(2)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关于屏蔽</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">从上面可以看出，屏蔽有两种方法，一种作用于</FONT><FONT FACE="Courier New" SIZE=3>CPU, </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>通过清除</FONT><FONT FACE="Courier New" SIZE=3>IF</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>标记，使得</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不去响应</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT FACE="Courier New" SIZE=3>INT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上的请求。也就是所谓关中断。</P>
<P ALIGN="JUSTIFY">另一种方法是，作用于</FONT><FONT FACE="Courier New" SIZE=3>8259,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>通过给它指令设置</FONT><FONT FACE="Courier New" SIZE=3>IMR,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>使得相应的</FONT><FONT FACE="Courier New" SIZE=3>IRR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不参与</FONT><FONT FACE="Courier New" SIZE=3>ISR(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>见上面的</FONT><FONT FACE="Courier New" SIZE=3>(4)),</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>被称为禁止</FONT><FONT FACE="Courier New" SIZE=3>(disable),</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>反之，被称为允许</FONT><FONT FACE="Courier New" SIZE=3>(enable).</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">每次设置</FONT><FONT FACE="Courier New" SIZE=3>IMR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>只需要对端口</FONT><FONT FACE="Courier New" SIZE=3>0x21(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>主</FONT><FONT FACE="Courier New" SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT FACE="Courier New" SIZE=3>0xA1(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>从</FONT><FONT FACE="Courier New" SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>输出一个字节即可，字节每位对应于</FONT><FONT FACE="Courier New" SIZE=3>IMR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>每位</FONT><FONT FACE="Courier New" SIZE=3>,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>例如</FONT><FONT FACE="Courier New" SIZE=3>:</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">outb(cached_21,0x21);</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">为了统一处理</FONT><FONT FACE="Courier New" SIZE=3>16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个中断，</FONT><FONT FACE="Courier New" SIZE=3>Linux</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用一个</FONT><FONT FACE="Courier New" SIZE=3>16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位</FONT><FONT FACE="Courier New" SIZE=3>cached_irq_mask</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>变量来记录这</FONT><FONT FACE="Courier New" SIZE=3>16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个中断的屏蔽情况</FONT><FONT FACE="Courier New" SIZE=3>:</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">static unsigned int cached_irq_mask = 0xffff;</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">为了分别对应于主从芯片的</FONT><FONT FACE="Courier New" SIZE=3>8</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位</FONT><FONT FACE="Courier New" SIZE=3>IMR,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>将这</FONT><FONT FACE="Courier New" SIZE=3>16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位</FONT><FONT FACE="Courier New" SIZE=3>cached_irq_mask</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>分成两个</FONT><FONT FACE="Courier New" SIZE=3>8</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位的变量</FONT><FONT FACE="Courier New" SIZE=3>:</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">#define __byte(x,y) (((unsigned char *)&amp;(y))[x])</P>
<P ALIGN="JUSTIFY">#define cached_21 (__byte(0,cached_irq_mask))</P>
<P ALIGN="JUSTIFY">#define cached_A1 (__byte(1,cached_irq_mask))</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在禁用某个</FONT><FONT FACE="Courier New" SIZE=3>irq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的时候</FONT><FONT FACE="Courier New" SIZE=3>,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>调用下面的函数</FONT><FONT FACE="Courier New" SIZE=3>:</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=1><P ALIGN="JUSTIFY">void disable_8259A_irq(unsigned int irq){&#9;</P><DIR>

<P ALIGN="JUSTIFY">unsigned int mask = 1 &lt;&lt; irq;&#9;unsigned long flags;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;</FONT><FONT FACE="Courier New" SIZE=1>spin_lock_irqsave(&amp;i8259A_lock, flags);&#9;</P>
<P ALIGN="JUSTIFY">cached_irq_mask |= mask;/*-- </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>对这</FONT><FONT FACE="Courier New" SIZE=1>16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位变量设置</FONT><FONT FACE="Courier New" SIZE=1>  */&#9;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"></P><DIR>
<DIR>
<DIR>

</FONT><FONT FACE="Courier New" SIZE=1><P ALIGN="JUSTIFY">if (irq &amp; 8)/*-- </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>看是对主</FONT><FONT FACE="Courier New" SIZE=1>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>设置还是对从芯片设置</FONT><FONT FACE="Courier New" SIZE=1>  */&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>&#9;&#9;</FONT><FONT FACE="Courier New" SIZE=1>          outb(cached_A1,0xA1);/*-- </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>对从</FONT><FONT FACE="Courier New" SIZE=1>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>芯片设置</FONT><FONT FACE="Courier New" SIZE=1>  */&#9;</P></DIR>
</DIR>
</DIR>

<P ALIGN="JUSTIFY">else&#9;&#9;</P><DIR>

<P ALIGN="JUSTIFY">outb(cached_21,0x21);/*-- </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>对主</FONT><FONT FACE="Courier New" SIZE=1>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>芯片设置</FONT><FONT FACE="Courier New" SIZE=1>  */&#9;spin_unlock_irqrestore(&amp;i8259A_lock, flags);</P></DIR>
</DIR>

<P ALIGN="JUSTIFY"> </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">(3)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关于中断号的输出</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT FACE="Courier New" SIZE=3>ISR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>里保存的只是</FONT><FONT FACE="Courier New" SIZE=3>irq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT FACE="Courier New" SIZE=3>ID,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>但是它告诉</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的是中断向量</FONT><FONT FACE="Courier New" SIZE=3>ID,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>比如</FONT><FONT FACE="Courier New" SIZE=3>ISR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>保存时钟中断的</FONT><FONT FACE="Courier New" SIZE=3>ID 0,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>但是在通知</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>却是中断号</FONT><FONT FACE="Courier New" SIZE=3>0x20.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>因此需要建立一个映射。在</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>芯片产生的</FONT><FONT FACE="Courier New" SIZE=3>IRQ</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>号必须是连续的，也就是如果</FONT><FONT FACE="Courier New" SIZE=3>irq0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对应的是中断向量</FONT><FONT FACE="Courier New" SIZE=3>0x20,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>那么</FONT><FONT FACE="Courier New" SIZE=3>irq1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对应的就是</FONT><FONT FACE="Courier New" SIZE=3>0x21,...</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在</FONT><FONT FACE="Courier New" SIZE=3>i8259.c/init_8259A()</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，进行设置</FONT><FONT FACE="Courier New" SIZE=3>:</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">        outb_p(0x11, 0x20); </FONT><FONT FACE="Courier New" SIZE=3 COLOR="#008080">/* ICW1: select 8259A-1 init */</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">        outb_p(0x20 + 0, 0x21); </FONT><FONT FACE="Courier New" SIZE=3 COLOR="#008080">/* ICW2: 8259A-1 IR0-7 mapped to 0x20-0x27 */</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">        outb_p(0x04, 0x21); </FONT><FONT FACE="Courier New" SIZE=3 COLOR="#008080">/* 8259A-1 (the master) has a slave on IR2 */</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">if (auto_eoi) </P>
<P ALIGN="JUSTIFY">        outb_p(0x03, 0x21); </FONT><FONT FACE="Courier New" SIZE=3 COLOR="#008080">/* master does Auto EOI */</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">else </P>
<P ALIGN="JUSTIFY">        outb_p(0x01, 0x21);</FONT><FONT FACE="Courier New" SIZE=3 COLOR="#008080"> /* master expects normal EOI */</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">        outb_p(0x11, 0xA0); </FONT><FONT FACE="Courier New" SIZE=3 COLOR="#008080">/* ICW1: select 8259A-2 init */</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">        outb_p(0x20 + 8, 0xA1);</FONT><FONT FACE="Courier New" SIZE=3 COLOR="#008080"> /* ICW2: 8259A-2 IR0-7 mapped to 0x28-0x2f */</P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">        outb_p(0x02, 0xA1);</FONT><FONT FACE="Courier New" SIZE=3 COLOR="#008080"> /* 8259A-2 is a slave on master's IR2 */</P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">        outb_p(0x01, 0xA1);</FONT><FONT FACE="Courier New" SIZE=3 COLOR="#008080"> /* (slave's support for AEOI in flat mode is to be investigated) */</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这样，在</FONT><FONT FACE="Courier New" SIZE=3>IDT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的向量</FONT><FONT FACE="Courier New" SIZE=3>0x20-0x2f</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以分别填入相应的中断处理函数的地址了。</P>
</FONT><B><FONT FACE="黑体" LANG="ZH-CN" SIZE=5><P ALIGN="JUSTIFY">向量表设置</P>
</B></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">注</FONT><FONT SIZE=3>:</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>图片均取自</FONT><FONT SIZE=3>i386</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>开发者手册</FONT><FONT SIZE=3>.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">i386</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中断门描述符</P>
<P ALIGN="JUSTIFY">描述符如图</FONT><FONT SIZE=3>:</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><IMG SRC="Image3.jpg" WIDTH=459 HEIGHT=269>段选择符和偏移量决定了中断处理函数的入口地址，如下图。</P>
<P ALIGN="JUSTIFY"><IMG SRC="Image4.jpg" WIDTH=444 HEIGHT=305></P>
<P ALIGN="JUSTIFY">在这里段选择符指向内核中唯一的一个代码段描述符的地址</FONT><FONT SIZE=3>__KERNEL_CS(=0x10)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，而这个描述符定义的段为</FONT><FONT SIZE=3>0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>到</FONT><FONT SIZE=3>4G:</P>
<P ALIGN="JUSTIFY">---------------------------------------------------------------------------------</P>
<P ALIGN="JUSTIFY">ENTRY(gdt_table)&#9;.quad 0x0000000000000000&#9;/* NULL descriptor */</P>
<P ALIGN="JUSTIFY">&#9;.quad 0x0000000000000000&#9;/* not used */&#9;</P>
<P ALIGN="JUSTIFY">.quad 0x00cf9a000000ffff&#9;/* 0x10 kernel 4GB code at 0x00000000 */</P>
<P ALIGN="JUSTIFY">... ...</P>
<P ALIGN="JUSTIFY">---------------------------------------------------------------------------------&#9;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">而偏移量就成了绝对的偏移量了，在</FONT><FONT SIZE=3>IDT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的描述符中被拆成了两部分，分别放在头和尾。</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">P</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>标志着这个代码段是否在内存中，本来是</FONT><FONT SIZE=3>i386</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>提供的类似缺页的机制，在</FONT><FONT SIZE=3>Linux</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中这个已经不用了，都设成</FONT><FONT SIZE=3>1(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>当然内核代码是永驻内存的，但即使不在内存，推测</FONT><FONT SIZE=3>linux</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>也只会用缺页的标志</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">DPL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在这里是</FONT><FONT SIZE=3>0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>级</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>特权级</FONT><FONT SIZE=3>)</P>
<P ALIGN="JUSTIFY">0D110</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，</FONT><FONT SIZE=3>D</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为</FONT><FONT SIZE=3>1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，表明是</FONT><FONT SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位程序</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这个细节见</FONT><FONT SIZE=3>i386</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>开发手册</FONT><FONT SIZE=3>).110</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是中断门的标识，其它</FONT><FONT SIZE=3>101</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是任务门的标识</FONT><FONT SIZE=3>, 111</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是陷阱</FONT><FONT SIZE=3>(trap)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>门标识。</P>
<P ALIGN="JUSTIFY">　</P>
</FONT><B><FONT SIZE=4><P ALIGN="JUSTIFY">Linux</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=4>对中断门的设置</P>
</B></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">于是在</FONT><FONT SIZE=3>Linux</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中对硬件中断的中断门的设置为</FONT><FONT SIZE=3>:</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"> init_IRQ(void)</P>
<P ALIGN="JUSTIFY">---------------------------------------------------------&#9;</P>
<P ALIGN="JUSTIFY">for (i = 0; i &lt; NR_IRQS; i++) {&#9;&#9;</P><DIR>

<P ALIGN="JUSTIFY">int vector = FIRST_EXTERNAL_VECTOR + i;</P>
<P ALIGN="JUSTIFY">&#9;if (vector != SYSCALL_VECTOR) &#9;&#9;&#9;</P><DIR>

<P ALIGN="JUSTIFY">set_intr_gate(vector, interrupt[ i]);</P></DIR>
</DIR>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">}</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">----------------------------------------------------------</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">其中，</FONT><FONT SIZE=3>FIRST_EXTERNAL_VECTOR=0x20,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>恰好为</FONT><FONT SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>芯片的</FONT><FONT SIZE=3>IR0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的中断门</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>见</FONT><FONT SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>部分</FONT><FONT SIZE=3>),</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>也就是时钟中断的中断门</FONT><FONT SIZE=3>),interrupt[ i]</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为相应处理函数的入口地址</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">NR_IRQS=224, =256(IDT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的向量总数</FONT><FONT SIZE=3>)-32(CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>保留的中断的个数</FONT><FONT SIZE=3>),</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在这里设置了所有可设置的向量。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">SYSCALL_VECTOR=0x80,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在这里意思是避开系统调用这个向量。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">而</FONT><FONT SIZE=3>set_intr_gate</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义是这样的</FONT><FONT SIZE=3>:</P>
<P ALIGN="JUSTIFY">----------------------------------------------------</P>
<P ALIGN="JUSTIFY">void set_intr_gate(unsigned int n, void *addr){&#9;</P><DIR>

<P ALIGN="JUSTIFY">_set_gate(idt_table+n,14,0,addr);</P></DIR>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">}</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">----------------------------------------------------</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">其中，需要解释的是</FONT><FONT SIZE=3>:14</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是标识指明这个是中断门</FONT><FONT SIZE=3>,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>注意上面的</FONT><FONT SIZE=3>0D110=01110=14;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>另外，</FONT><FONT SIZE=3>0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指明的是</FONT><FONT SIZE=3>DPL.</P>
</FONT><B><FONT FACE="黑体" LANG="ZH-CN" SIZE=5><P ALIGN="JUSTIFY">中断入口</P>
</B></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">以</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT FACE="Courier New" SIZE=3>16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个中断为例</FONT><FONT FACE="Courier New" SIZE=3>:</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">通过宏</FONT><FONT FACE="Courier New" SIZE=3>BUILD_16_IRQS(0x0), BI(x,y),</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>以及</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">#define BUILD_IRQ(nr) \</P>
<P ALIGN="JUSTIFY">asmlinkage void IRQ_NAME(nr); \</P>
<P ALIGN="JUSTIFY">__asm__( \</P>
<P ALIGN="JUSTIFY">"\n"__ALIGN_STR"\n" \</P>
<P ALIGN="JUSTIFY">SYMBOL_NAME_STR(IRQ) #nr "_interrupt:\n\t" \</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">&#9;</FONT><FONT FACE="Courier New" SIZE=3>"pushl $"#nr"-256\n\t" \</P>
<P ALIGN="JUSTIFY">&#9;"jmp common_interrupt");</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">得到的</FONT><FONT FACE="Courier New" SIZE=3>16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个中断处理函数为</FONT><FONT FACE="Courier New" SIZE=3>:</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">IRQ0x00_interrupt:</P>
<P ALIGN="JUSTIFY">push $0x00 - 256</P>
<P ALIGN="JUSTIFY">jump common_interrupt</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">IRQ0x00_interrupt:</P>
<P ALIGN="JUSTIFY">push $0x01 - 256</P>
<P ALIGN="JUSTIFY">jump common_interrupt</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">... ...</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">IRQ0x0f_interrupt:</P>
<P ALIGN="JUSTIFY">push $0x0f - 256</P>
<P ALIGN="JUSTIFY">jump common_interrupt</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这些处理函数简单的把中断号</FONT><FONT FACE="Courier New" SIZE=3>-256(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为什么</FONT><FONT FACE="Courier New" SIZE=3>-256</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，也许是避免和内部中断的中断号有冲突</FONT><FONT FACE="Courier New" SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>压到栈中，然后跳到</FONT><FONT FACE="Courier New" SIZE=3>common_interrupt</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">其中</FONT><FONT FACE="Courier New" SIZE=3>common_interrupt</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是由宏</FONT><FONT FACE="Courier New" SIZE=3>BUILD_COMMON_IRQ()</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>展开</FONT><FONT FACE="Courier New" SIZE=3>:</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">　</P>
<P ALIGN="JUSTIFY">#define BUILD_COMMON_IRQ() \</P>
<P ALIGN="JUSTIFY">asmlinkage void call_do_IRQ(void); \</P>
<P ALIGN="JUSTIFY">__asm__( \&#9;</P>
<P ALIGN="JUSTIFY">"\n" __ALIGN_STR"\n" \</P>
<P ALIGN="JUSTIFY">&#9;"common_interrupt:\n\t" \</P>
<P ALIGN="JUSTIFY">&#9;SAVE_ALL \&#9;</P>
<P ALIGN="JUSTIFY">"pushl $ret_from_intr\n\t" \</P>
<P ALIGN="JUSTIFY"> SYMBOL_NAME_STR(call_do_IRQ)":\n\t" \</P>
<P ALIGN="JUSTIFY">&#9;"jmp "SYMBOL_NAME_STR(do_IRQ));</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">.align 4,0x90common_interrupt:</P>
<P ALIGN="JUSTIFY">     SAVE_ALL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>展开的保护现场部分</P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">     push $ret_from_intrcall </P>
<P ALIGN="JUSTIFY">do_IRQ:             </P>
<P ALIGN="JUSTIFY">          jump do_IRQ;  </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">从上面可以看出，这</FONT><FONT FACE="Courier New" SIZE=3>16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个的中断处理函数不过是把中断号</FONT><FONT FACE="Courier New" SIZE=3>-256</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>压入栈中，然后保护现场，最后调用</FONT><FONT FACE="Courier New" SIZE=3>do_IRQ .</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT FACE="Courier New" SIZE=3>common_interrupt</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，为了使</FONT><FONT FACE="Courier New" SIZE=3>do_IRQ</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回到</FONT><FONT FACE="Courier New" SIZE=3>entry.S</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT FACE="Courier New" SIZE=3>ret_from_intr</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>标号，所以采用的是压入返回点</FONT><FONT FACE="Courier New" SIZE=3>ret_from_intr,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用</FONT><FONT FACE="Courier New" SIZE=3>jump</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来模拟一个从</FONT><FONT FACE="Courier New" SIZE=3>ret_from_intr</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上面对</FONT><FONT FACE="Courier New" SIZE=3>do_IRQ</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的一个调用。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">　</P>
<B><I><P ALIGN="JUSTIFY">和</FONT><FONT FACE="Courier New" SIZE=3>IDT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的衔接</P>
</B></I><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">为了便于</FONT><FONT FACE="Courier New" SIZE=3>IDT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的设置，在数组</FONT><FONT FACE="Courier New" SIZE=3>interrupt</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中填入所有中断处理函数的地址</FONT><FONT FACE="Courier New" SIZE=3>:</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">void (*interrupt[NR_IRQS])(void) = {&#9;</P>
<P ALIGN="JUSTIFY">IRQ0x00_interrupt,&#9;</P>
<P ALIGN="JUSTIFY">IRQ0x01_interrupt,&#9;</P>
<P ALIGN="JUSTIFY">... ...</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">}&#9;</P>
<P ALIGN="JUSTIFY">在中断门的设置中，可以看到是如何利用这个数组的。</P>
</FONT><B><FONT FACE="黑体" LANG="ZH-CN" SIZE=5><P ALIGN="JUSTIFY">硬件中断处理函数</FONT><FONT FACE="Courier New" SIZE=5>do_IRQ</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">do_IRQ</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=4>的相关对象</P>
</B></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在</FONT><FONT FACE="Courier New" SIZE=3>do_IRQ</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，一个中断主要由三个对象来完成，如图</FONT><FONT FACE="Courier New" SIZE=3>:</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><IMG SRC="Image5.jpg" WIDTH=557 HEIGHT=220></P>
<P ALIGN="JUSTIFY">其中</FONT><FONT FACE="Courier New" SIZE=3>, irq_desc_t</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象构成的</FONT><FONT FACE="Courier New" SIZE=3>irq_desc[]</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>数组元素分别对应了</FONT><FONT FACE="Courier New" SIZE=3>224</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个硬件中断</FONT><FONT FACE="Courier New" SIZE=3>(idt</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>一共</FONT><FONT FACE="Courier New" SIZE=3>256</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>项，</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>自己前保留了</FONT><FONT FACE="Courier New" SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>项，</FONT><FONT FACE="Courier New" SIZE=3>256-32=224</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，当然这里面有些项是不用的，比如</FONT><FONT FACE="Courier New" SIZE=3>x80</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是系统调用</FONT><FONT FACE="Courier New" SIZE=3>).</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">当发生中断时，函数</FONT><FONT FACE="Courier New" SIZE=3>do_IRQ</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就会在</FONT><FONT FACE="Courier New" SIZE=3>irq_desc[]</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>相应的项中提取各种信息来完成对中断的处理。</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">irq_desc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>有一个字段</FONT><FONT FACE="Courier New" SIZE=3>handler</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向发出这个中断的设备的处理对象</FONT><FONT FACE="Courier New" SIZE=3>hw_irq_controller,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>比如在单</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，这个对象一般就是处理芯片</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的对象。为什么要指向这个对象呢？因为当发生中断的时候，内核需要对相应的中断进行一些处理，比如屏蔽这个中断等。这个时候需要对中断设备</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>比如</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>芯片</FONT><FONT FACE="Courier New" SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>进行操作，于是可以通过这个指针指向的对象进行操作。</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">irq_desc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>还有一个字段</FONT><FONT FACE="Courier New" SIZE=3>action</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向对象</FONT><FONT FACE="Courier New" SIZE=3>irqaction</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，后者是产生中断的设备的处理对象，其中的</FONT><FONT FACE="Courier New" SIZE=3>handler</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就是处理函数。由于一个中断可以由多个设备发出，</FONT><FONT FACE="Courier New" SIZE=3>Linux</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>内核采用轮询的方式，将所有产生这个中断的设备的处理对象连成一个链表，一个一个执行。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">例如，硬盘</FONT><FONT FACE="Courier New" SIZE=3>1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，硬盘</FONT><FONT FACE="Courier New" SIZE=3>2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>都产生中断</FONT><FONT FACE="Courier New" SIZE=3>IRQx,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT FACE="Courier New" SIZE=3>do_IRQ</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中首先找到</FONT><FONT FACE="Courier New" SIZE=3>irq_desc[x],</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>通过字段</FONT><FONT FACE="Courier New" SIZE=3>handler</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对产生中断</FONT><FONT FACE="Courier New" SIZE=3>IRQx</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的设备进行处理</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>而言，就是屏蔽以后的中断</FONT><FONT FACE="Courier New" SIZE=3>IRQx),</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>然后通过</FONT><FONT FACE="Courier New" SIZE=3>action</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>先后运行硬盘</FONT><FONT FACE="Courier New" SIZE=3>1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和硬盘</FONT><FONT FACE="Courier New" SIZE=3>2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的处理函数。</P>
<P ALIGN="JUSTIFY">　</P>
</FONT><B><FONT FACE="Courier New" SIZE=4><P ALIGN="JUSTIFY">hw_irq_controller</P>
</B></FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">hw_irq_controller</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>有多种</FONT><FONT FACE="Courier New" SIZE=3>: </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">1.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在一般单</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的机器上，通常采用两个</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>芯片，因此</FONT><FONT FACE="Courier New" SIZE=3>hw_irq_controller</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指的就是</FONT><FONT FACE="Courier New" SIZE=3>i8259A_irq_type </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">2.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在多</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的机器上，采用</FONT><FONT FACE="Courier New" SIZE=3>APIC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>子系统来处理芯片，</FONT><FONT FACE="Courier New" SIZE=3>APIC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>有</FONT><FONT FACE="Courier New" SIZE=3>3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个部分组成，一个是</FONT><FONT FACE="Courier New" SIZE=3>I/O APIC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>模块，其作用可比做</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>芯片，但是它发出的中断信号会通过</FONT><FONT FACE="Courier New" SIZE=3> APIC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>总线送到其中一个</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或几个</FONT><FONT FACE="Courier New" SIZE=3>)CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的</FONT><FONT FACE="Courier New" SIZE=3>Local APIC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>模块，因此，它还起一个路由的作用；它可以接收</FONT><FONT FACE="Courier New" SIZE=3>16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个中断。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">中断可以采取两种方式，电平触发和边沿触发，相应的，</FONT><FONT FACE="Courier New" SIZE=3>I/O APIC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>模块的</FONT><FONT FACE="Courier New" SIZE=3>hw_irq_controller</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就有两种</FONT><FONT FACE="Courier New" SIZE=3>: </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">ioapic_level_irq_type </P>
<P ALIGN="JUSTIFY">ioapic_edge_irq_type </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这里指的是</FONT><FONT FACE="Courier New" SIZE=3>intel</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT FACE="Courier New" SIZE=3>APIC,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>还有其它公司研制的</FONT><FONT FACE="Courier New" SIZE=3>APIC,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>我没有研究过</FONT><FONT FACE="Courier New" SIZE=3>) </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">3. Local APIC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>自己也能单独处理一些直接对</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>产生的中断，例如时钟中断</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这和没有使用</FONT><FONT FACE="Courier New" SIZE=3>Local APIC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>模块的</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不同，它们接收的时钟中断来自外围的时钟芯片</FONT><FONT FACE="Courier New" SIZE=3>),</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>因此，它也有自己的</FONT><FONT FACE="Courier New" SIZE=3> hw_irq_controller: </P>
<P ALIGN="JUSTIFY">lapic_irq_type </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">struct hw_interrupt_type { </P>
<P ALIGN="JUSTIFY">const char * typename; </P>
<P ALIGN="JUSTIFY">unsigned int (*startup)(unsigned int irq); </P>
<P ALIGN="JUSTIFY">void (*shutdown)(unsigned int irq); </P>
<P ALIGN="JUSTIFY">void (*enable)(unsigned int irq); </P>
<P ALIGN="JUSTIFY">void (*disable)(unsigned int irq); </P>
<P ALIGN="JUSTIFY">void (*ack)(unsigned int irq); </P>
<P ALIGN="JUSTIFY">void (*end)(unsigned int irq); </P>
<P ALIGN="JUSTIFY">void (*set_affinity)(unsigned int irq, unsigned long mask); </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">}</FONT><FONT FACE="Courier New" SIZE=3>; </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">typedef struct hw_interrupt_type hw_irq_controller; </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">　</P><DIR>
<DIR>
<DIR>

<B><P ALIGN="JUSTIFY">startup</B>  </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是启动中断芯片</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>模块</FONT><FONT FACE="Courier New" SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，使得它开始接收中断，一般情况下，就是将</FONT><FONT FACE="Courier New" SIZE=3>     </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所有被屏蔽的引脚取消屏蔽</FONT><FONT FACE="Courier New" SIZE=3> </P></DIR>
</DIR>
</DIR>

<B><P ALIGN="JUSTIFY">shutdown</B> </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>反之，使得芯片不再接收中断</FONT><FONT FACE="Courier New" SIZE=3> </P>
<B><P ALIGN="JUSTIFY">enable</B>   </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>设某个引脚可以接收中断，也就是取消屏蔽</FONT><FONT FACE="Courier New" SIZE=3> </P>
<B><P ALIGN="JUSTIFY">disable  </B></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>屏蔽某个引脚，例如，如果屏蔽</FONT><FONT FACE="Courier New" SIZE=3>0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>那么时钟中断就不再发生</FONT><FONT FACE="Courier New" SIZE=3> </P><DIR>
<DIR>
<DIR>

<B><P ALIGN="JUSTIFY">ack</B>       </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>当</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>收到来自中断芯片的中断信号，给相应的引脚的处理</FONT><FONT FACE="Courier New" SIZE=3>,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这个各种情况下</FONT><FONT FACE="Courier New" SIZE=3>         (8259, APIC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>电平，边沿</FONT><FONT FACE="Courier New" SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的处理都不相同</FONT><FONT FACE="Courier New" SIZE=3> </P></DIR>
</DIR>
</DIR>

<B><P ALIGN="JUSTIFY">end</B>      </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>处理完某个引脚产生的中断后，对中断芯片</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>模块</FONT><FONT FACE="Courier New" SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的操作。</FONT><FONT FACE="Courier New" SIZE=3> </P>
</FONT><B><FONT SIZE=4><P ALIGN="JUSTIFY">irqaction</P>
</B></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">将一个硬件处理函数挂到相应的处理队列上去</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>当然首先要生成一个</FONT><FONT FACE="Courier New" SIZE=3>irqaction</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>结构</FONT><FONT FACE="Courier New" SIZE=3>): </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">----------------------------------------------------- </P>
<P ALIGN="JUSTIFY">int request_irq(unsigned int irq, </P>
<P ALIGN="JUSTIFY">&#9;&#9;void (*handler)(int, void *, struct pt_regs *),</P>
<P ALIGN="JUSTIFY">&#9;&#9;unsigned long irqflags, </P>
<P ALIGN="JUSTIFY">&#9;&#9;const char * devname,</P>
<P ALIGN="JUSTIFY">&#9;&#9;void *dev_id)</P>
<P ALIGN="JUSTIFY">-----------------------------------------------------&#9;&#9;</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">参数说明在源文件里说得非常清楚。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">handler</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是硬件处理函数，在下面的代码中可以看得很清楚</FONT><FONT FACE="Courier New" SIZE=3>: </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">---------------------------------------------</P>
<P ALIGN="JUSTIFY">&#9;do {</P>
<P ALIGN="JUSTIFY">&#9;&#9;status |= action-&gt;flags;</P>
<P ALIGN="JUSTIFY">&#9;&#9;action-&gt;handler(irq, action-&gt;dev_id, regs);</P>
<P ALIGN="JUSTIFY">&#9;&#9;action = action-&gt;next;</P>
<P ALIGN="JUSTIFY">&#9;} while (action);</P>
<P ALIGN="JUSTIFY">---------------------------------------------</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">第二个参数就是</FONT><FONT FACE="Courier New" SIZE=3>action</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT FACE="Courier New" SIZE=3>dev_id,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这个参数非常灵活，可以派各种用处。而且要保证的是，这个</FONT><FONT FACE="Courier New" SIZE=3>dev_id</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在这个处理链中是唯一的，否则删除会遇到麻烦。</FONT><FONT FACE="Courier New" SIZE=3> </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">第三个参数是在</FONT><FONT FACE="Courier New" SIZE=3>entry.S</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中压入的各个积存器的值。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">它的大致流程是</FONT><FONT FACE="Courier New" SIZE=3>: </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">1.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT FACE="Courier New" SIZE=3>slab</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中分配一个</FONT><FONT FACE="Courier New" SIZE=3>irqaction</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，填上必需的数据</FONT><FONT FACE="Courier New" SIZE=3> </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">以下在函数</FONT><FONT FACE="Courier New" SIZE=3>setup_irq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">2.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>找到它的</FONT><FONT FACE="Courier New" SIZE=3>irq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对应的结构</FONT><FONT FACE="Courier New" SIZE=3>irq_desc </P>
<P ALIGN="JUSTIFY">3.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>看它是否想对随机数做贡献</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">4.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>看这个结构上是否已经挂了其它处理函数了，如果有，则必须确保它本身和这个队列上所有的处理函数都是可共享的</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>由于传递性，只需判断一个就可以了</FONT><FONT FACE="Courier New" SIZE=3>) </P>
<P ALIGN="JUSTIFY">5.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>挂到队列最后</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">6.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果这个</FONT><FONT FACE="Courier New" SIZE=3>irq_desc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>只有它一个</FONT><FONT FACE="Courier New" SIZE=3>irqaction,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>那么还要进行一些初始化工作</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">7</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT FACE="Courier New" SIZE=3>proc/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>下面登记</FONT><FONT FACE="Courier New" SIZE=3> register_irq_proc(irq)(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这个我不太明白</FONT><FONT FACE="Courier New" SIZE=3>) </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">将一个处理函数取下</FONT><FONT FACE="Courier New" SIZE=3>: </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">void free_irq(unsigned int irq, void *dev_id) </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">首先在队列里找到这个处理函数</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>严格的说是</FONT><FONT FACE="Courier New" SIZE=3>irqaction),</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>主要靠</FONT><FONT FACE="Courier New" SIZE=3>dev_id</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来匹配，这时</FONT><FONT FACE="Courier New" SIZE=3>dev_id</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的唯一性就比较重要了。</FONT><FONT FACE="Courier New" SIZE=3> </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">将它从队列里剔除。</FONT><FONT FACE="Courier New" SIZE=3> </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">如果这个中断号没有处理函数了，那么禁止这个中断号上再产生中断</FONT><FONT FACE="Courier New" SIZE=3>: </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;if (!desc-&gt;action) {</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;desc-&gt;status |= IRQ_DISABLED;</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;desc-&gt;handler-&gt;shutdown(irq);</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;}</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">如果其它</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在运行这个处理函数，要等到它运行完了，才释放它</FONT><FONT FACE="Courier New" SIZE=3>: </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">#ifdef CONFIG_SMP </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">/* Wait to make sure it's not being used on another CPU */ </P>
<P ALIGN="JUSTIFY">while (desc-&gt;status &amp; IRQ_INPROGRESS) </P>
<P ALIGN="JUSTIFY">barrier(); </P>
<P ALIGN="JUSTIFY">#endif </P>
<P ALIGN="JUSTIFY">kfree(action); </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">　</P>
</FONT><B><FONT SIZE=4><P ALIGN="JUSTIFY">do_IRQ</P>
</B></FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">asmlinkage unsigned int do_IRQ(struct pt_regs regs)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">1.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>首先取中断号</FONT><FONT FACE="Courier New" SIZE=3>,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>并且获取对应的</FONT><FONT FACE="Courier New" SIZE=3>irq_desc:</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;</FONT><FONT FACE="Courier New" SIZE=3>int irq = regs.orig_eax &amp; 0xff; /* high bits used in ret_from_ code  */</P>
<P ALIGN="JUSTIFY">&#9;int cpu = smp_processor_id();</P>
<P ALIGN="JUSTIFY">&#9;irq_desc_t *desc = irq_desc + irq;</P>
<P ALIGN="JUSTIFY">&#9;</P>
<P ALIGN="JUSTIFY">2.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对中断芯片</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>模块</FONT><FONT FACE="Courier New" SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应答</FONT><FONT FACE="Courier New" SIZE=3>:</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">desc-&gt;handler-&gt;ack(irq);</P>
<P ALIGN="JUSTIFY">&#9;</P>
<P ALIGN="JUSTIFY">3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>．修改它的状态（注：这些状态我觉得只有在</FONT><FONT FACE="Courier New" SIZE=3>SMP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>下才有意义）：</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">   status = desc-&gt;status &amp; ~(IRQ_REPLAY | IRQ_WAITING);</P>
<P ALIGN="JUSTIFY">&#9;status |= IRQ_PENDING; /* we _want_ to handle it */</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">IRQ_REPLAY</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是指如果被禁止的中断号上又产生了中断，这个中断是不会被处理的，当这个中断号被允许产生中断时，会将这个未被处理的中断转为</FONT><FONT FACE="Courier New" SIZE=3>IRQ_REPLAY</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</FONT><FONT FACE="Courier New" SIZE=3> </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">IRQ_WAITING </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>探测用，探测时，会将所有没有挂处理函数的中断号上设置</FONT><FONT FACE="Courier New" SIZE=3>IRQ_WAITING,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果这个中断号上有中断产生，就把这个状态去掉，因此，我们就可以知道哪些中断引脚上产生过中断了。</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">IRQ_PENDING</FONT><FONT SIZE=3> ,</FONT><FONT FACE="Courier New" SIZE=3> IRQ_INPROGRESS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是为了确保</FONT><FONT FACE="Courier New" SIZE=3>:</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<OL>

<P ALIGN="JUSTIFY"><LI>同一个中断号的处理程序不能重入</LI></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY"><LI>   </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不能丢失这个中断号的下一个处理程序</LI></P></OL>

<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">具体的说</FONT><FONT FACE="Courier New" SIZE=3>,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>当内核在运行某个中断号对应的处理程序</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>链</FONT><FONT FACE="Courier New" SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>时，状态会设置成</FONT><FONT FACE="Courier New" SIZE=3>IRQ_INPROGRESS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。如果在这期间，同一个中断号上又产生了中断，并且传给</FONT><FONT FACE="Courier New" SIZE=3>CPU,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>那么当内核打算再次运行这个中断号对应的处理程序</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>链</FONT><FONT FACE="Courier New" SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>时，发现已经有一个实例在运行了，就将这下一个中断标注为</FONT><FONT FACE="Courier New" SIZE=3>IRQ_PENDING, </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>然后返回。这个已在运行的实例结束的时候，会查看是否期间有同一中断发生了，是则再次执行一遍。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">这些状态的操作不是在什么情况下都必须的，事实上，一个</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，用</FONT><FONT FACE="Courier New" SIZE=3>8259</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>芯片，无论即使是开中断，也不会发生中断重入的情况，因为在这期间，内核把同一中断屏蔽掉了。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">多个</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>比较复杂，因为</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>由</FONT><FONT FACE="Courier New" SIZE=3>Local APIC,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>每个都有自己的中断，但是它们可能调用同一个函数，比如时钟中断，每个</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>都可能产生，它们都会调用时钟中断处理函数。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">从</FONT><FONT FACE="Courier New" SIZE=3>I/O APIC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>传过来的中断</FONT><FONT FACE="Courier New" SIZE=3>,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果是电平触发，也不会，因为在结束发出</FONT><FONT FACE="Courier New" SIZE=3>EOI</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>前，这个引脚上是不接收中断信号。如果是边沿触发，要么是开中断，要么</FONT><FONT FACE="Courier New" SIZE=3>I/O APIC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>选择不同的</FONT><FONT FACE="Courier New" SIZE=3>CPU,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在这两种情况下，会有重入的可能。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;</FONT><FONT FACE="Courier New" SIZE=3>/*</P>
<P ALIGN="JUSTIFY">&#9; * If the IRQ is disabled for whatever reason, we cannot</P>
<P ALIGN="JUSTIFY">&#9; * use the action we have.</P>
<P ALIGN="JUSTIFY">&#9; */</P>
<P ALIGN="JUSTIFY">&#9;action = NULL;</P>
<P ALIGN="JUSTIFY">&#9;if (!(status &amp; (IRQ_DISABLED | IRQ_INPROGRESS))) {</P>
<P ALIGN="JUSTIFY">&#9;&#9;action = desc-&gt;action;</P>
<P ALIGN="JUSTIFY">&#9;&#9;status &amp;= ~IRQ_PENDING; /* we commit to handling */</P>
<P ALIGN="JUSTIFY">&#9;&#9;status |= IRQ_INPROGRESS; /* we are handling it *//*</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>进入执行状态</FONT><FONT FACE="Courier New" SIZE=3>*/</P>
<P ALIGN="JUSTIFY">&#9;}</P>
<P ALIGN="JUSTIFY">&#9;desc-&gt;status = status;</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;/*</P>
<P ALIGN="JUSTIFY">&#9; * If there is no IRQ handler or it was disabled, exit early.</P>
<P ALIGN="JUSTIFY">&#9;   Since we set PENDING, if another processor is handling</P>
<P ALIGN="JUSTIFY">&#9;   a different instance of this same irq, the other processor</P>
<P ALIGN="JUSTIFY">&#9;   will take care of it.</P>
<P ALIGN="JUSTIFY">&#9; */</P>
<P ALIGN="JUSTIFY">&#9;if (!action)</P>
<P ALIGN="JUSTIFY">&#9;&#9;goto out;/*</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>要么该中断没有处理函数；要么被禁止运行</FONT><FONT FACE="Courier New" SIZE=3>(IRQ_DISABLE);</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>要么有一个实例已经在运行了</FONT><FONT FACE="Courier New" SIZE=3>*/</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;</FONT><FONT FACE="Courier New" SIZE=3>/*</P>
<P ALIGN="JUSTIFY">&#9; * Edge triggered interrupts need to remember</P>
<P ALIGN="JUSTIFY">&#9; * pending events.</P>
<P ALIGN="JUSTIFY">&#9; * This applies to any hw interrupts that allow a second</P>
<P ALIGN="JUSTIFY">&#9; * instance of the same irq to arrive while we are in do_IRQ</P>
<P ALIGN="JUSTIFY">&#9; * or in the handler. But the code here only handles the _second_</P>
<P ALIGN="JUSTIFY">&#9; * instance of the irq, not the third or fourth. So it is mostly</P>
<P ALIGN="JUSTIFY">&#9; * useful for irq hardware that does not mask cleanly in an</P>
<P ALIGN="JUSTIFY">&#9; * SMP environment.</P>
<P ALIGN="JUSTIFY">&#9; */</P>
<P ALIGN="JUSTIFY">&#9;for (;;) {</P>
<P ALIGN="JUSTIFY">&#9;&#9;spin_unlock(&amp;desc-&gt;lock);</P>
<P ALIGN="JUSTIFY">&#9;&#9;handle_IRQ_event(irq, &amp;regs, action);/*</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>执行函数链</FONT><FONT FACE="Courier New" SIZE=3>*/</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">&#9;&#9;</FONT><FONT FACE="Courier New" SIZE=3>spin_lock(&amp;desc-&gt;lock);</P>
<P ALIGN="JUSTIFY">&#9;&#9;</P>
<P ALIGN="JUSTIFY">&#9;&#9;if (!(desc-&gt;status &amp; IRQ_PENDING))/*</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>发现期间有中断，就再次执行</FONT><FONT FACE="Courier New" SIZE=3>*/</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;break;</P>
<P ALIGN="JUSTIFY">&#9;&#9;desc-&gt;status &amp;= ~IRQ_PENDING;</P>
<P ALIGN="JUSTIFY">&#9;}</P>
<P ALIGN="JUSTIFY">&#9;desc-&gt;status &amp;= ~IRQ_INPROGRESS;/*</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>退出执行状态</FONT><FONT FACE="Courier New" SIZE=3>*/</P>
<P ALIGN="JUSTIFY">out:</P>
<P ALIGN="JUSTIFY">&#9;/*</P>
<P ALIGN="JUSTIFY">&#9; * The -&gt;end() handler has to deal with interrupts which got</P>
<P ALIGN="JUSTIFY">&#9; * disabled while the handler was running.</P>
<P ALIGN="JUSTIFY">&#9; */</P>
<P ALIGN="JUSTIFY">&#9;desc-&gt;handler-&gt;end(irq);/*</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>给中断芯片一个结束的操作</FONT><FONT FACE="Courier New" SIZE=3>,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>一般是允许再次接收中断</FONT><FONT FACE="Courier New" SIZE=3>*/</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">&#9;</FONT><FONT FACE="Courier New" SIZE=3>spin_unlock(&amp;desc-&gt;lock);</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;if (softirq_active(cpu) &amp; softirq_mask(cpu))</P>
<P ALIGN="JUSTIFY">&#9;&#9;do_softirq();/*</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>执行软中断</FONT><FONT FACE="Courier New" SIZE=3>*/</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">&#9;</FONT><FONT FACE="Courier New" SIZE=3>return 1;</P>
<P ALIGN="JUSTIFY">}</P>
</FONT><B><FONT FACE="黑体" LANG="ZH-CN" SIZE=5><P ALIGN="JUSTIFY">软中断</FONT><FONT FACE="Arial" SIZE=5>softirq</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=4>简介</P>
</B></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><IMG SRC="Image6.jpg" WIDTH=552 HEIGHT=372>提出</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的机制的目的和老版本的底半部分的目的是一致的，都是将某个中断处理的一部分任务延迟到后面去执行。</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">Linux</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>内核中一共可以有</FONT><FONT FACE="Courier New" SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个</FONT><FONT FACE="Courier New" SIZE=3>softirq,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>每个</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>实际上就是指向一个函数。当内核执行</FONT><FONT FACE="Courier New" SIZE=3>softirq(do_softirq),</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就对这</FONT><FONT FACE="Courier New" SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>进行轮询：</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">(1)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是否该</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>被定义了，并且允许被执行</FONT><FONT FACE="Courier New" SIZE=3>?</P>
<P ALIGN="JUSTIFY">(2)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是否激活了</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>也就是以前有中断要求它执行</FONT><FONT FACE="Courier New" SIZE=3>)?</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">如果得到肯定的答复，那么就执行这个</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向的函数。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">值得一提的是，无论有多少个</FONT><FONT FACE="Courier New" SIZE=3>CPU,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>内核一共只有</FONT><FONT FACE="Courier New" SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个公共的</FONT><FONT FACE="Courier New" SIZE=3>softirq,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>但是每个</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以执行不同的</FONT><FONT FACE="Courier New" SIZE=3>softirq,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以禁止</FONT><FONT FACE="Courier New" SIZE=3>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>起用不同的</FONT><FONT FACE="Courier New" SIZE=3>softirq,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以激活不同的</FONT><FONT FACE="Courier New" SIZE=3>softirq,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>因此，可以说，所有</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>有相同的例程，但是</P>
<P ALIGN="JUSTIFY">每个</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>却有自己完全独立的实例。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">对</FONT><FONT FACE="Courier New" SIZE=3>(1)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的判断是通过考察</FONT><FONT FACE="Courier New" SIZE=3>irq_stat[ cpu ].mask</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>相应的位得到的。这里面的</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指的是当前指令所在的</FONT><FONT FACE="Courier New" SIZE=3>cpu.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在一开始，</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>被定义时，所有的</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的掩码</FONT><FONT FACE="Courier New" SIZE=3>mask</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>都是一样的。但是在实际运行中，每个</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上运行的程序可以根据自己的需要调整。</P>
<P ALIGN="JUSTIFY">对</FONT><FONT FACE="Courier New" SIZE=3>(2)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的判断是通过考察</FONT><FONT FACE="Courier New" SIZE=3>irq_stat[ cpu ].active</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>相应的位得到的</FONT><FONT FACE="Courier New" SIZE=3>.</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">虽然原则上可以任意定义每个</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的函数，</FONT><FONT FACE="Courier New" SIZE=3>Linux</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>内核为了进一步加强延迟中断功能，提出了</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的机制。</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>实际上也就是一个函数。在第</FONT><FONT FACE="Courier New" SIZE=3>0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的处理函数</FONT><FONT FACE="Courier New" SIZE=3>tasklet_hi_action</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，我们可以看到，当执行这个函数的时候，会依次执行一个链表上所有的</FONT><FONT FACE="Courier New" SIZE=3>tasklet.</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">我们大致上可以把</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的机制概括成</FONT><FONT FACE="Courier New" SIZE=3>:</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">内核依次对</FONT><FONT FACE="Courier New" SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>轮询，如果遇到一个可以执行并且需要的</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，就执行对应的函数，这些函数有可能又会执行一个函数队列。当执行完这个函数队列后，才会继续询问下一个</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对应的函数。</P>
<P ALIGN="JUSTIFY">　</P>
</FONT><B><FONT SIZE=4><P ALIGN="JUSTIFY"> </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=4>挂上一个软中断</FONT><FONT SIZE=4> </P>
</B></FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">void open_softirq(int nr, void (*action)(struct softirq_action*), void *data)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">&#9;unsigned long flags;</P>
<P ALIGN="JUSTIFY">&#9;int i;</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;spin_lock_irqsave(&amp;softirq_mask_lock, flags);</P>
<P ALIGN="JUSTIFY">&#9;softirq_vec[nr].data = data;</P>
<P ALIGN="JUSTIFY">&#9;softirq_vec[nr].action = action;</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;for (i=0; i&lt;NR_CPUS; i++)</P>
<P ALIGN="JUSTIFY">&#9;&#9;softirq_mask(i) |= (1&lt;&lt;nr);</P>
<P ALIGN="JUSTIFY">&#9;spin_unlock_irqrestore(&amp;softirq_mask_lock, flags);</P>
<P ALIGN="JUSTIFY">}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">其中对每个</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT FACE="Courier New" SIZE=3>softirq_mask</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>都标注一下，表明这个</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>被定义了。</P>
</FONT><B><FONT SIZE=4><P ALIGN="JUSTIFY">tasklet </P>
</B></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在这个</FONT><FONT FACE="Courier New" SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，有的</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的函数会依次执行一个队列中的</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，如第一帖中图所示。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>其实就是一个函数。它的结构如下</FONT><FONT FACE="Courier New" SIZE=3>: </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">struct tasklet_struct</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">&#9;struct tasklet_struct *next;</P>
<P ALIGN="JUSTIFY">&#9;unsigned long state;</P>
<P ALIGN="JUSTIFY">&#9;atomic_t count;</P>
<P ALIGN="JUSTIFY">&#9;void (*func)(unsigned long);</P>
<P ALIGN="JUSTIFY">&#9;unsigned long data;</P>
<P ALIGN="JUSTIFY">};</P>
<P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">next</B>  </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用于将</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>串成一个队列</FONT><FONT FACE="Courier New" SIZE=3> </P>
<B><P ALIGN="JUSTIFY">state</B> </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>表示一些状态，后面详细讨论</FONT><FONT FACE="Courier New" SIZE=3> </P><DIR>
<DIR>

<B><P ALIGN="JUSTIFY">count</B> </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用来禁用</FONT><FONT FACE="Courier New" SIZE=3>(count = 1 )</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或者启用</FONT><FONT FACE="Courier New" SIZE=3>( count = 0 )</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这个</FONT><FONT FACE="Courier New" SIZE=3>tasklet.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>因为一旦一个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>被挂到队列里，如果没有这个机制，它就一定会被执行。</FONT><FONT FACE="Courier New" SIZE=3> </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这个</FONT><FONT FACE="Courier New" SIZE=3>count</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>算是一个事后补救措施，万一挂上了不想执行，就可以把它置</FONT><FONT FACE="Courier New" SIZE=3>1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</FONT><FONT FACE="Courier New" SIZE=3> </P></DIR>
</DIR>

<B><P ALIGN="JUSTIFY">func</B>  </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>即为所要执行的函数。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<B><P ALIGN="JUSTIFY">data</B>  </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>由于可能多个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>调用公用函数，因此用</FONT><FONT FACE="Courier New" SIZE=3>data</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以区分不同</FONT><FONT FACE="Courier New" SIZE=3>tasklet. </P>
<P ALIGN="JUSTIFY"></P>
</FONT><B><I><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">如何将一个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>挂上</P>
</B></I><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">首先要初始化一个</FONT><FONT FACE="Courier New" SIZE=3>tasklet,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>填上相应的参数</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">void tasklet_init(struct tasklet_struct *t,</P>
<P ALIGN="JUSTIFY">&#9;&#9;  void (*func)(unsigned long), unsigned long data)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">&#9;t-&gt;func = func;</P>
<P ALIGN="JUSTIFY">&#9;t-&gt;data = data;</P>
<P ALIGN="JUSTIFY">&#9;t-&gt;state = 0;</P>
<P ALIGN="JUSTIFY">&#9;atomic_set(&amp;t-&gt;count, 0);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">然后调用</FONT><FONT FACE="Courier New" SIZE=3>schedule</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数，注意，下面的函数仅仅是将这个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>挂到</FONT><FONT FACE="Courier New" SIZE=3> TASKLET_SOFTIRQ</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对应的软中断所执行的</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>队列上去，</FONT><FONT FACE="Courier New" SIZE=3> </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>事实上，还有其它的软中断，比如</FONT><FONT FACE="Courier New" SIZE=3>HI_SOFTIRQ,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>会执行其它的</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>队列，如果要挂上，那么就要调用</FONT><FONT FACE="Courier New" SIZE=3>tasklet_hi_schedule(). </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果你自己写的</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>执行一个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>队列，那么你需要自己写类似下面的函数。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">static inline void tasklet_schedule(struct tasklet_struct *t)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">&#9;if (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state)) {</P>
<P ALIGN="JUSTIFY">&#9;&#9;int cpu = smp_processor_id();</P>
<P ALIGN="JUSTIFY">&#9;&#9;unsigned long flags;</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;&#9;local_irq_save(flags);</P>
<P ALIGN="JUSTIFY">/**/&#9;&#9;t-&gt;next = tasklet_vec[cpu].list;</P>
<P ALIGN="JUSTIFY">/**/&#9;&#9;tasklet_vec[cpu].list = t;</P>
<P ALIGN="JUSTIFY">&#9;&#9;__cpu_raise_softirq(cpu, TASKLET_SOFTIRQ);</P>
<P ALIGN="JUSTIFY">&#9;&#9;local_irq_restore(flags);</P>
<P ALIGN="JUSTIFY">&#9;}</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这个函数中</FONT><FONT FACE="Courier New" SIZE=3>/**/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>标注的句子用来挂接上</FONT><FONT FACE="Courier New" SIZE=3>tasklet, </P>
<P ALIGN="JUSTIFY">__cpu_raise_softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用来激活</FONT><FONT FACE="Courier New" SIZE=3>TASKLET_SOFTIRQ,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这样，下次执行</FONT><FONT FACE="Courier New" SIZE=3>do_softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就会执行这个</FONT><FONT FACE="Courier New" SIZE=3>TASKLET_SOFTIRQ</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>软中断了</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">__cpu_raise_softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>定义如下</FONT><FONT FACE="Courier New" SIZE=3>: </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">static inline void __cpu_raise_softirq(int cpu, int nr)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">&#9;softirq_active(cpu) |= (1&lt;&lt;nr);</P>
<P ALIGN="JUSTIFY">}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
</FONT><B><I><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">  tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的运行方式</FONT><FONT FACE="Courier New" SIZE=3> </P>
</B></I></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">我们以</FONT><FONT FACE="Courier New" SIZE=3>tasklet_action</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为例，来说明</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>运行机制。事实上，还有一个函数</FONT><FONT FACE="Courier New" SIZE=3>tasklet_hi_action</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>同样也运行</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>队列。</FONT><FONT FACE="Courier New" SIZE=3> </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">首先值得注意的是，我们前面提到过，所有的</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>共用</FONT><FONT FACE="Courier New" SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，但是同一个</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在不同的</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上执行的数据是独立的，基于这个原则，</FONT><FONT FACE="Courier New" SIZE=3>tasklet_vec</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对每个</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>都有一个，每个</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>都运行自己的</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>队列。</FONT><FONT FACE="Courier New" SIZE=3> </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><IMG SRC="Image7.jpg" WIDTH=348 HEIGHT=260></FONT><FONT FACE="Courier New" SIZE=3> </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">当执行一个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>队列时，内核将这个队列摘下来，以</FONT><FONT FACE="Courier New" SIZE=3>list</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为队列头，然后从</FONT><FONT FACE="Courier New" SIZE=3>list</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的下一个开始依次执行。这样做达到什么效果呢？在执行这个队列时，这个队列的结构是静止的，如果在运行期间，有中断产生，并且往这个队列里添加</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的话，将填加到</FONT><FONT FACE="Courier New" SIZE=3>tasklet_vec[cpu].list</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，</FONT><FONT FACE="Courier New" SIZE=3> </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>注意这个时候，这个队列里的任何</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>都不会被执行，被执行的是</FONT><FONT FACE="Courier New" SIZE=3>list</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>接管的队列。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">见</FONT><FONT FACE="Courier New" SIZE=3>/*1*//*2/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>之间的代码。事实上，在一个队列上同时添加和运行也是可行的，没这个简洁。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">-----------------------------------------------------------------</P>
<P ALIGN="JUSTIFY">static void tasklet_action(struct softirq_action *a)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">&#9;int cpu = smp_processor_id();</P>
<P ALIGN="JUSTIFY">&#9;struct tasklet_struct *list;</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">/*1*/&#9;local_irq_disable();</P>
<P ALIGN="JUSTIFY">&#9;    list = tasklet_vec[cpu].list;</P>
<P ALIGN="JUSTIFY">&#9;    tasklet_vec[cpu].list = NULL;</P>
<P ALIGN="JUSTIFY">/*2*/&#9;local_irq_enable();</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;     while (list != NULL) {</P>
<P ALIGN="JUSTIFY">&#9;&#9;    struct tasklet_struct *t = list;</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;&#9;    list = list-&gt;next;</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">/*3*/&#9;&#9;if (tasklet_trylock(t)) {</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;if (atomic_read(&amp;t-&gt;count) == 0) {</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;clear_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state);</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;t-&gt;func(t-&gt;data);</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;/*</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9; * talklet_trylock() uses test_and_set_bit that imply</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9; * an mb when it returns zero, thus we need the explicit</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9; * mb only here: while closing the critical section.</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9; */</P>
<P ALIGN="JUSTIFY">#ifdef CONFIG_SMP</P>
<P ALIGN="JUSTIFY">/*?*/&#9;&#9;&#9;&#9;smp_mb__before_clear_bit();</P>
<P ALIGN="JUSTIFY">#endif</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;tasklet_unlock(t);</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;continue;</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;}</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;tasklet_unlock(t);</P>
<P ALIGN="JUSTIFY">&#9;&#9;}</P>
<P ALIGN="JUSTIFY">/*4*/&#9;local_irq_disable();</P>
<P ALIGN="JUSTIFY">&#9;&#9;t-&gt;next = tasklet_vec[cpu].list;</P>
<P ALIGN="JUSTIFY">&#9;&#9;tasklet_vec[cpu].list = t;</P>
<P ALIGN="JUSTIFY">&#9;&#9;__cpu_raise_softirq(cpu, TASKLET_SOFTIRQ);</P>
<P ALIGN="JUSTIFY">/*5*/&#9;&#9;local_irq_enable();</P>
<P ALIGN="JUSTIFY">&#9;}</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">-------------------------------------------------------------</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">/*3*/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>看其它</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是否还有同一个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在执行，如果有的话，就首先将这个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>重新放到</FONT><FONT FACE="Courier New" SIZE=3>tasklet_vec[cpu].list</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向的预备队列</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>见</FONT><FONT FACE="Courier New" SIZE=3>/*4*/~/*5*/)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，而后跳过这个</FONT><FONT FACE="Courier New" SIZE=3>tasklet. </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这也就说明了</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是不可重入的，以防止两个相同的</FONT><FONT FACE="Courier New" SIZE=3>tasket</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>访问同样的变量而产生竞争条件</FONT><FONT FACE="Courier New" SIZE=3>(race condition) </P>
</FONT><B><I><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的状态</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
</B></I></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在</FONT><FONT FACE="Courier New" SIZE=3>tasklet_struct</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中有一个属性</FONT><FONT FACE="Courier New" SIZE=3>state</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，用来表示</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的状态：</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的状态有</FONT><FONT FACE="Courier New" SIZE=3>3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个：</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">1.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>当</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>被挂到队列上，还没有执行的时候，是</FONT><FONT FACE="Courier New" SIZE=3> TASKLET_STATE_SCHED </P>
<P ALIGN="JUSTIFY">2.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>当</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>开始要被执行的时候，是</FONT><FONT FACE="Courier New" SIZE=3> TASKLET_STATE_RUN </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">其它时候，则没有这两个位的设置</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">其实还有另一对状态，禁止或允许，</FONT><FONT FACE="Courier New" SIZE=3>tasklet_struct</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中用</FONT><FONT FACE="Courier New" SIZE=3>count</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>表示</FONT><FONT FACE="Courier New" SIZE=3>,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用下面的函数操作</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">　</P>
<P ALIGN="JUSTIFY">　</P>
<P ALIGN="JUSTIFY">-----------------------------------------------------</P>
<P ALIGN="JUSTIFY">static inline void tasklet_disable_nosync(struct tasklet_struct *t)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">&#9;atomic_inc(&amp;t-&gt;count);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">static inline void tasklet_disable(struct tasklet_struct *t)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">&#9;tasklet_disable_nosync(t);</P>
<P ALIGN="JUSTIFY">&#9;tasklet_unlock_wait(t);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">static inline void tasklet_enable(struct tasklet_struct *t)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">&#9;atomic_dec(&amp;t-&gt;count);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">-------------------------------------------------------</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">下面来验证</FONT><FONT FACE="Courier New" SIZE=3>1,2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这两个状态</FONT><FONT FACE="Courier New" SIZE=3>: </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">当被挂上队列时</FONT><FONT FACE="Courier New" SIZE=3>: </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">首先要测试它是否已经被别的</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>挂上了，如果已经在别的</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>挂上了，则不再将它挂上，否则设置状态为</FONT><FONT FACE="Courier New" SIZE=3>TASKLET_STATE_SCHED </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">　</P>
<P ALIGN="JUSTIFY">static inline void tasklet_schedule(struct tasklet_struct *t)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">&#9;if (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state)) {</P>
<P ALIGN="JUSTIFY">... ...</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">为什么要这样做</FONT><FONT FACE="Courier New" SIZE=3>?</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>试想，如果一个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>已经挂在一队列上，内核将沿着这个队列一个个执行，现在如果又被挂到另一个队列上，那么这个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的指针</FONT><FONT FACE="Courier New" SIZE=3> </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">指向另一个队列，内核就会沿着它走到错误的队列中去了。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">　</P>
<P ALIGN="JUSTIFY">tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>开始执行时</FONT><FONT FACE="Courier New" SIZE=3>: </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在</FONT><FONT FACE="Courier New" SIZE=3>tasklet_action</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中</FONT><FONT FACE="Courier New" SIZE=3>:</P>
<P ALIGN="JUSTIFY">------------------------------------------------------------</P>
<P ALIGN="JUSTIFY">&#9;while (list != NULL) {</P>
<P ALIGN="JUSTIFY">&#9;&#9;struct tasklet_struct *t = list;</P>
<P ALIGN="JUSTIFY">/*0*/&#9;&#9;list = list-&gt;next;</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">/*1*/&#9;&#9;if (tasklet_trylock(t)) {</P>
<P ALIGN="JUSTIFY">/*2*/&#9;&#9;&#9;if (atomic_read(&amp;t-&gt;count) == 0) {</P>
<P ALIGN="JUSTIFY">/*3*/&#9;&#9;&#9;&#9;clear_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state);</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;t-&gt;func(t-&gt;data);</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;/*</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9; * talklet_trylock() uses test_and_set_bit that imply</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9; * an mb when it returns zero, thus we need the explicit</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9; * mb only here: while closing the critical section.</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9; */</P>
<P ALIGN="JUSTIFY">#ifdef CONFIG_SMP</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;smp_mb__before_clear_bit();</P>
<P ALIGN="JUSTIFY">#endif</P>
<P ALIGN="JUSTIFY">/*4*/&#9;&#9;&#9;&#9;tasklet_unlock(t);</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;continue;</P>
<P ALIGN="JUSTIFY">&#9;&#9;&#9;}</P>
<P ALIGN="JUSTIFY">---------------------------------------------------------------&#9;&#9;&#9;</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">1 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>看是否是别的</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上这个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>已经是</FONT><FONT FACE="Courier New" SIZE=3> TASKLET_STATE_RUN</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>了，如果是就跳过这个</FONT><FONT FACE="Courier New" SIZE=3>tasklet </P>
<P ALIGN="JUSTIFY">2 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>看这个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是否被允许运行</FONT><FONT FACE="Courier New" SIZE=3>? </P>
<P ALIGN="JUSTIFY">3 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>清除</FONT><FONT FACE="Courier New" SIZE=3>TASKLET_STATE_SCHED</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，为什么现在清除，它不是还没有从队列上摘下来吗？事实上，它的指针已经不再需要的，它的下一个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>已经被</FONT><FONT FACE="Courier New" SIZE=3>list</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>记录了</FONT><FONT FACE="Courier New" SIZE=3>(/*0*/)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。这样，如果其它</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>把它挂到其它的队列上去一点影响都没有。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">4 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>清除</FONT><FONT FACE="Courier New" SIZE=3>TASKLET_STATE_RUN</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>标志</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT FACE="Courier New" SIZE=3>4</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>确保了在所有</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上，不可能运行同一个</FONT><FONT FACE="Courier New" SIZE=3>tasklet,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这样在一定程度上确保了</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对数据操作是安全的，但是不要忘了，多个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可能指向同一个函数，所以仍然会发生竞争条件。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">可能会有疑问</FONT><FONT FACE="Courier New" SIZE=3>:</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>假设</FONT><FONT FACE="Courier New" SIZE=3>cpu 1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上已经有</FONT><FONT FACE="Courier New" SIZE=3>tasklet 1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>挂在队列上了，</FONT><FONT FACE="Courier New" SIZE=3>cpu2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应该根本挂不上同一个</FONT><FONT FACE="Courier New" SIZE=3>tasklet 1,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>怎么会有</FONT><FONT FACE="Courier New" SIZE=3>tasklet 1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和它发生重入的情况呢</FONT><FONT FACE="Courier New" SIZE=3>? </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">答案就在</FONT><FONT FACE="Courier New" SIZE=3>/*3*/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上，当</FONT><FONT FACE="Courier New" SIZE=3>cpu 1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT FACE="Courier New" SIZE=3>tasklet 1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>已经不是</FONT><FONT FACE="Courier New" SIZE=3>TASKLET_STATE_SCHED</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，而它还在运行，这时</FONT><FONT FACE="Courier New" SIZE=3>cpu2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>完全有可能挂上同一个</FONT><FONT FACE="Courier New" SIZE=3>tasklet 1,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>而且使得它试图运行，这时</FONT><FONT FACE="Courier New" SIZE=3>/*1*/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的判断就起作用了。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
</FONT><B><I><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">软中断的重入</FONT><FONT FACE="Courier New" SIZE=3> </P>
</B></I></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><IMG SRC="Image8.jpg" WIDTH=552 HEIGHT=329></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY"> </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如图，一般情况下，在硬件中断处理程序后都会试图调用</FONT><FONT FACE="Courier New" SIZE=3>do_softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>执行软中断，但是如果发现现在已经有中断在运行，或者已经有软中断在运行，则</FONT><FONT FACE="Courier New" SIZE=3> </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">不再运行自己调用的中断。也就是说，软中断是不能进入硬件中断部分的</FONT><FONT FACE="Courier New" SIZE=3>,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>并且软中断在一个</FONT><FONT FACE="Courier New" SIZE=3>cpu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上是不可重入的，或者说是串行化的</FONT><FONT FACE="Courier New" SIZE=3>(serialize) </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">其目的是避免访问同样的变量导致竞争条件的出现。在开中断的中断处理程序中不允许调用软中断可能是希望这个中断处理程序尽快结束。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这是由</FONT><FONT FACE="Courier New" SIZE=3>do_softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;if (in_interrupt())</P>
<P ALIGN="JUSTIFY">&#9;&#9;return;</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">保证的</FONT><FONT FACE="Courier New" SIZE=3>. </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">其中，</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">#define in_interrupt() ({ int __cpu = smp_processor_id(); \ </P>
<P ALIGN="JUSTIFY">(local_irq_count(__cpu) + local_bh_count(__cpu) != 0); }) </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">前者</FONT><FONT FACE="Courier New" SIZE=3>local_irq_count(_cpu):</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">当进入硬件中断处理程序时，</FONT><FONT FACE="Courier New" SIZE=3>handle_IRQ_event</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的</FONT><FONT FACE="Courier New" SIZE=3>irq_enter(cpu, irq)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>会将它加</FONT><FONT FACE="Courier New" SIZE=3>1,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>表明又进入一个硬件中断</FONT><FONT FACE="Courier New" SIZE=3> </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">退出则调用</FONT><FONT FACE="Courier New" SIZE=3>irq_exit(cpu, irq) </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">后者</FONT><FONT FACE="Courier New" SIZE=3>local_bh_count(__cpu) :</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">当进入软中断处理程序时，</FONT><FONT FACE="Courier New" SIZE=3>do_softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的</FONT><FONT FACE="Courier New" SIZE=3>local_bh_disable()</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>会将它加</FONT><FONT FACE="Courier New" SIZE=3>1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，表明处于软中断中</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">local_bh_disable(); </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">一个例子：</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">当内核正在执行处理定时器的软中断时，这期间可能会发生多个时钟中断，这些时钟中断的处理程序都试图再次运行处理定时器的软中断，但是由于</FONT><FONT FACE="Courier New" SIZE=3> </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>已经有个软中断在运行了，于是就放弃返回。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"> </P>
</FONT><B><FONT FACE="Courier New" SIZE=4><P ALIGN="JUSTIFY">  </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=4>软中断调用时机</FONT><FONT FACE="Courier New" SIZE=4> </P>
</B></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">最直接的调用：</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">当硬中断执行完后，迅速调用</FONT><FONT FACE="Courier New" SIZE=3>do_softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来执行软中断</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>见下面的代码</FONT><FONT FACE="Courier New" SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，这样，被硬中断标注的软中断能得以迅速执行。当然，不是每次调用都成功的，见前面关于重入的帖子。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY">-----------------------------------------------------</P>
<P ALIGN="JUSTIFY">asmlinkage unsigned int do_IRQ(struct pt_regs regs)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">... ...</P>
<P ALIGN="JUSTIFY">&#9;if (softirq_active(cpu) &amp; softirq_mask(cpu))</P>
<P ALIGN="JUSTIFY">&#9;&#9;do_softirq();</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">-----------------------------------------------------</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">还有，不是每个被标注的软中断都能在这次陷入内核的部分中完成，可能会延迟到下次中断。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">其它地方的调用</FONT><FONT FACE="Courier New" SIZE=3>: </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在</FONT><FONT FACE="Courier New" SIZE=3>entry.S</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中有一个调用点</FONT><FONT FACE="Courier New" SIZE=3>: </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">handle_softirq:</P>
<P ALIGN="JUSTIFY">&#9;call SYMBOL_NAME(do_softirq)</P>
<P ALIGN="JUSTIFY">&#9;jmp ret_from_intr</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">有两处调用它，一处是当系统调用处理完后</FONT><FONT FACE="Courier New" SIZE=3>: </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">ENTRY(ret_from_sys_call)</P>
<P ALIGN="JUSTIFY">#ifdef CONFIG_SMP</P>
<P ALIGN="JUSTIFY">&#9;movl processor(%ebx),%eax</P>
<P ALIGN="JUSTIFY">&#9;shll $CONFIG_X86_L1_CACHE_SHIFT,%eax</P>
<P ALIGN="JUSTIFY">&#9;movl SYMBOL_NAME(irq_stat)(,%eax),%ecx&#9;&#9;# softirq_active</P>
<P ALIGN="JUSTIFY">&#9;testl SYMBOL_NAME(irq_stat)+4(,%eax),%ecx&#9;# softirq_mask</P>
<P ALIGN="JUSTIFY">#else</P>
<P ALIGN="JUSTIFY">&#9;movl SYMBOL_NAME(irq_stat),%ecx&#9;&#9;# softirq_active</P>
<P ALIGN="JUSTIFY">&#9;testl SYMBOL_NAME(irq_stat)+4,%ecx&#9;# softirq_mask</P>
<P ALIGN="JUSTIFY">#endif</P>
<P ALIGN="JUSTIFY">&#9;jne   handle_softirq</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">一处是当异常处理完后：</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">ret_from_exception:</P>
<P ALIGN="JUSTIFY">#ifdef CONFIG_SMP</P>
<P ALIGN="JUSTIFY">&#9;GET_CURRENT(%ebx)</P>
<P ALIGN="JUSTIFY">&#9;movl processor(%ebx),%eax</P>
<P ALIGN="JUSTIFY">&#9;shll $CONFIG_X86_L1_CACHE_SHIFT,%eax</P>
<P ALIGN="JUSTIFY">&#9;movl SYMBOL_NAME(irq_stat)(,%eax),%ecx&#9;&#9;# softirq_active</P>
<P ALIGN="JUSTIFY">&#9;testl SYMBOL_NAME(irq_stat)+4(,%eax),%ecx&#9;# softirq_mask</P>
<P ALIGN="JUSTIFY">#else</P>
<P ALIGN="JUSTIFY">&#9;movl SYMBOL_NAME(irq_stat),%ecx&#9;&#9;# softirq_active</P>
<P ALIGN="JUSTIFY">&#9;testl SYMBOL_NAME(irq_stat)+4,%ecx&#9;# softirq_mask</P>
<P ALIGN="JUSTIFY">#endif</P>
<P ALIGN="JUSTIFY">&#9;jne   handle_softirq</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">注意其中的</FONT><FONT FACE="Courier New" SIZE=3>irq_stat, irq_stat +4 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对应的就是字段</FONT><FONT FACE="Courier New" SIZE=3> active</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT FACE="Courier New" SIZE=3>mask </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">既然我们每次调用完硬中断后都马上调用软中断，为什么还要在这里调用呢</FONT><FONT FACE="Courier New" SIZE=3>? </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">原因可能都多方面的</FONT><FONT FACE="Courier New" SIZE=3>: </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(1)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在系统调用或者异常处理中同样可以标注软中断，这样它们在返回前就能得以迅速执行</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(2)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>前面提到，有些软中断要延迟到下次陷入内核才能执行，系统调用和异常都陷入内核，所以可以尽早的把软中断处理掉</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(3)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果在异常或者系统调用中发生中断，那么前面提到，可能还会有一些软中断没有处理，在这两个地方做一个补救工作，尽量避免到下次陷入内核才处理这些软中断。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P>另外，在切换前也调用。</P>
<P ALIGN="JUSTIFY"></P>
</FONT><B><I><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">  bottom half</P>
<P ALIGN="JUSTIFY"></P>
</B></I><P ALIGN="JUSTIFY">2.2.x</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的</FONT><FONT FACE="Courier New" SIZE=3>bottom half :</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">2.2.x</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>版本中的</FONT><FONT FACE="Courier New" SIZE=3>bottom half</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就相当于</FONT><FONT FACE="Courier New" SIZE=3>2.4.1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的</FONT><FONT FACE="Courier New" SIZE=3>softirq.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>它的问题在于只有</FONT><FONT FACE="Courier New" SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个</FONT><FONT FACE="Courier New" SIZE=3>,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果要扩充的话，需要</FONT><FONT FACE="Courier New" SIZE=3>task </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>队列</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这里</FONT><FONT FACE="Courier New" SIZE=3>task</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不是进程，而是函数</FONT><FONT FACE="Courier New" SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，还有一个比较大的问题，就是虽然</FONT><FONT FACE="Courier New" SIZE=3>bottom half</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在一个</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上是串行的</FONT><FONT FACE="Courier New" SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>由</FONT><FONT FACE="Courier New" SIZE=3>local_bh_count[cpu]</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>记数保证</FONT><FONT FACE="Courier New" SIZE=3>),</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>但是在多</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上是不安全的，例如，一个</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上在运行关于定时器的</FONT><FONT FACE="Courier New" SIZE=3>bottom half,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>另一个</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>也可以运行同一个</FONT><FONT FACE="Courier New" SIZE=3>bottom half,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>出现了重入。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
<B><I><P ALIGN="JUSTIFY">2.4.1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的</FONT><FONT FACE="Courier New" SIZE=3>bottom half </P>
</B></I></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">2.4.1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，用</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>表示</FONT><FONT FACE="Courier New" SIZE=3>bottom half, mark_bh</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就是将相应的</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>挂到运行队列里</FONT><FONT FACE="Courier New" SIZE=3>tasklet_hi_vec[cpu].list,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这个队列由</FONT><FONT FACE="Courier New" SIZE=3>HI_SOFTIRQ</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对应的</FONT><FONT FACE="Courier New" SIZE=3>softirq</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来执行。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">另外，用一个全局锁来保证，当一个</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上运行一个</FONT><FONT FACE="Courier New" SIZE=3>bottom half</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>时，其它</FONT><FONT FACE="Courier New" SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>上不能运行任何一个</FONT><FONT FACE="Courier New" SIZE=3>bottom half</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。这和以前的</FONT><FONT FACE="Courier New" SIZE=3>bottom half</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>有所不同，不知道是否我看错了。</FONT><FONT FACE="Courier New" SIZE=3> </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">用</FONT><FONT FACE="Courier New" SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来表示</FONT><FONT FACE="Courier New" SIZE=3>bottom half: </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">struct tasklet_struct bh_task_vec[32]; </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">首先，初始化所有的</FONT><FONT FACE="Courier New" SIZE=3>bottom half: </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">void __init softirq_init()</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">... ...</P>
<P ALIGN="JUSTIFY">&#9;for (i=0; i&lt;32; i++)</P>
<P ALIGN="JUSTIFY">&#9;&#9;tasklet_init(bh_task_vec+i, bh_action, i);</P>
<P ALIGN="JUSTIFY">... ...</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这里</FONT><FONT FACE="Courier New" SIZE=3>bh_action</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是下面的函数，它使得</FONT><FONT FACE="Courier New" SIZE=3>bottom half</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>运行对应的</FONT><FONT FACE="Courier New" SIZE=3>bh_base</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY">static void bh_action(unsigned long nr)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">&#9;int cpu = smp_processor_id();</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">/*1*/&#9;if (!spin_trylock(&amp;global_bh_lock))</P>
<P ALIGN="JUSTIFY">&#9;&#9;goto resched;</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;if (!hardirq_trylock(cpu))</P>
<P ALIGN="JUSTIFY">&#9;&#9;goto resched_unlock;</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;if (bh_base[nr])</P>
<P ALIGN="JUSTIFY">&#9;&#9;bh_base[nr]();</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&#9;hardirq_endlock(cpu);</P>
<P ALIGN="JUSTIFY">&#9;spin_unlock(&amp;global_bh_lock);</P>
<P ALIGN="JUSTIFY">&#9;return;</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">resched_unlock:</P>
<P ALIGN="JUSTIFY">&#9;spin_unlock(&amp;global_bh_lock);</P>
<P ALIGN="JUSTIFY">resched:</P>
<P ALIGN="JUSTIFY">&#9;mark_bh(nr);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"> /*1*/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>试图上锁</FONT><FONT FACE="Courier New" SIZE=3>,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果得不到锁，则重新将</FONT><FONT FACE="Courier New" SIZE=3>bottom half</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>挂上，下次在运行。</P>
</FONT><FONT FACE="Courier New" SIZE=3><P ALIGN="JUSTIFY"> </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">当要定义一个</FONT><FONT FACE="Courier New" SIZE=3>bottom half</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>时用下面的函数</FONT><FONT FACE="Courier New" SIZE=3>:</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">void init_bh(int nr, void (*routine)(void))</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">&#9;bh_base[nr] = routine;</P>
<P ALIGN="JUSTIFY">&#9;mb();</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">取消定义时，用</FONT><FONT FACE="Courier New" SIZE=3>:</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">void remove_bh(int nr)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">&#9;tasklet_kill(bh_task_vec+nr);</P>
<P ALIGN="JUSTIFY">&#9;bh_base[nr] = NULL;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY"> </P>
<P ALIGN="JUSTIFY">tasklet_kill</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>确保这个</FONT><FONT FACE="Courier New" SIZE=3>tasklet</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>被运行了，因而它的指针也没有用了。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">激活一个</FONT><FONT FACE="Courier New" SIZE=3>bottom half,</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就是将它挂到队列中</FONT><FONT FACE="Courier New" SIZE=3> :</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">static inline void mark_bh(int nr)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">&#9;tasklet_hi_schedule(bh_task_vec+nr);</P>
<P ALIGN="JUSTIFY">}</P></FONT></BODY>
</HTML>
