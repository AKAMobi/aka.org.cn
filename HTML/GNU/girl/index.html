<html>
<head><title>GIRL设计方案</title></head>
<body>
<h1 align=center>GIRL设计方案</h1>
<p align=center>请在此处添加计数器</p>
<p align=right>Charles 1999.9
<hr>
<p>各位朋友，大家好，让大家久等了。本来可以早些提交设计方案的，可以因为长沙这几天天气
太热，大家都开空调，电压很低，没法使用电脑。而且热得头晕，唉。。。。。。
<p>我在网上用过很多名字，实际上往往是申请免费电子邮件箱的时候为了避免冲突瞎想出来的，哈哈。
大家就叫我Charles好了。这个名字是我们的英语老师给起的，我还算满意。
<p>我最早接触X Window环境下的界面开发工具包是在1996年。那时候我需要使用Motif制作一个简单的
界面。Motif的与MFC、OWL不同的思维方式引起了我的很大兴趣，在1996年下半年、1997年上半年，
我在DOS平台下自行实现了一些窗口元素。为了能够充分体会窗口系统的构成原理，没有使用任何
开发工具，直接写屏、直接访问键盘、直接访问鼠标驱动程序。尤其是1997年上半年写的第2版，自行
佩带了资源编译器。功能比较完善。到了今年（1999），我注意到了linux，实际上可以说是一见钟情。
因为它或许是我们中国人快速进入系统软件领域的唯一途径。起点当然就是本人的拿手戏，界面开发
工具了。于是就有了GIRL。
<p>GIRL是图形界面表述语言（Graphic Interface Represent Language）的缩写，当然本人也很喜欢
GIRL了。:)
<p>GIRL是描述性的、界面构件类说明语言。GIRL编译器编译GIRL源文件生成C/C++语言源文件，而后再
由C/C++编译器编译连接成GIRL静态或动态连接库。由于GIRL仅仅描述界面构件类，GIRL应用程序还需要
和C/C++语言代码相连接，以完成所需要的功能。为了使C/C++程序方便地访问GIRL源文件定义的类或
对象，GIRL还提供了一组面向C/C++语言的应用程序界面（SDK）。在GIRL源文件中，可以定义的对象有：
颜色、光标、字体、位图。C/C++程序可以通过SDK访问这些对象。但是不能够对这些对象进行任何修改。
此外，C/C++程序还可以利用SDK动态地创建颜色、光标、字体、位图对象，并动态地删除它们。

<p>界面开发工具包在窗口系统中的重要地位，相信大家都已经十分清楚了。在设计GIRL之前，深入地
研究现有的经典GUI Tool Kit是绝对必要的。linux的开发方式告诉我们，闭门造车只有死路一条。
所以，为了把GIRL设计好（对于GUI Tool Kit来说，设计比实现重要得多，没有那个使用者希望工具包
随着版本的不同变来变去），我认为首先应该对设计方案进行充分的讨论，集思广益，使GIRL成为我们
大家共同的Daughter。
<hr>
<h2>1。目前在X Window系统中流行的工具包</h2>
<ul>
<li>Qt：Qt是由挪威的Troll Tech公司开发的，面向C++的界面开发工具包。它对常用的界面构件有很好
的支持。除了基本的界面元素之外，还较好地支持了界面绘图操作。Qt的最大特点是通过信号（signal）
与（slot）进行连接、信号与信号的连接、虚函数的重载实现各种功能。Qt的最新版本是2.0，大约有
14万行代码。关于Qt的详细情况，可以访问<a href="http://www.troll.no/">Troll Tech</a>的网站。
用Qt创作的主要作品为：KDE、Koffice、Kdevelop。（大名鼎鼎呦）
<li>GTK+：GTK+是由伯克利的Peter Mattis、Spencer Kimball、Josh MacDonald共同设计的。它是面向
C语言的。实现了所有主要的界面构件。得到了广泛的应用。GTK+实际上由GLib、GDK、GTK三个部分组成。
在GTK+中，也可以进行信号连接。它的最新版本1.2.4，据说1.2.5版就快发布了。1.2.3版大约包含14万
行代码（有些巧合）。关于GTK+的详细情况，可以访问<a href="http://www.gtk.org/">
http://www.gtk.org</a>。用GTK+创作的主要作品有：GNOME、GIMP。（耳熟能详也）
<li>Motif：实际上Motif不是自由软件。与GTK+类似，Motif也是面向C语言的。主要支持各种界面构件。
由于Motif出现的很早，得到很多商家的支持。Motif规范的最新版本好像是2.0。Motif的自由软件实现
被称为LessTif。但是LessTif只实现了Motif规范的1.2版。Motif/LessTif给我印象最深的就是：提供了
静态说明构件的UIL、构件之间可以按照粘连的方式组织（XmForm）。关于LessTif，请访问<a href=
"http://www.lesstif.org/">http://www.lesstif.org</a>。
Motif主要应用与商业软件，利用LessTif开发的自由软件不多。
<li>Tcl/Tk：Tcl是一种便于扩展的脚本语言，Tk就是Tcl关于软件界面的一个主要扩展。由于脚本语言
是解释执行的，效率受到一定影响，往往不被用于大型的应用程序。但是因为编程简单，非常适合简单
的界面程序。Tcl/Tk出现与80年代，经过十多年的发展，获得了众多的支持。与Tcl/Tk相关的站点很多。
主要的有：<a href="http://www.scriptics.com/">http://www.scriptics.com</a>、<a href=
"http://www.tclconsortium.org/">http://www.tclconsortium.org</a>。
</ul>
<h2>2。GIRL的设计思路</h2>
<p>如果希望设计一个好的界面开发工具包，对界面应用程序规律的研究是必不可少的。在我编程的
实践中，感觉到现代图形界面应用程序的基本特征有：
<ul>
<li>工作方式的一致性：几乎所有界面应用程序都是事件驱动的。它们的工作流程基本上可以概括为：
<ul>
  <li>创建、组织界面元素；
  <li>向界面元素注入原始数据；
  <li>进入事件循环等待事件发生；
  <li>根据事件从界面中获取数据、修改界面元素的数据；
  <li>在预定的条件下（例如发生应用程序终止事件）退出事件循环；
  <li>删除界面元素，并且退出应用程序。
</ul>
<p>对于某些应用程序，还需要注册空闲函数，在没有出现任何事件的情况下完成预定的操作。必要典型
的有：媒体播放器、游戏等等。
<li>界面元素的静态性：图形界面应用程序的绝大部分界面元素是固定不变的。也就是说，界面由那些
元素构成、这些元素的排列方式、位置、界面元素内容的含义、界面元素内容之间的相互关系（约束）
在应用程序完成编译以前就完全确定了。在本文中，称之为静态定义。变化的通常只是界面元素中的
数据。当然，还是可能出现在运行是确定界面构成的情况。对话框编辑器就是一个典型的例子。
</ul>
<p>把上述特征与常用的开发工具包相比较，可以发现多数工具包在对界面应用程序工作的整个过程的
支持中，没有很好地利用界面元素的静态性。应用程序必须自行设计构造界面的过程、自行维护界面
数据之间约束关系。
<p>虽然界面开发工具包不可能包办所有与界面相关的工作，但是尽可能地简化界面编程却是界面开发
工具包的主要任务。创建界面的过程，在应用程序代码中往往占据了相当大的比重。事实上应用程序的
使用者并不关心界面是如何创建的，界面元素是如何组织的。用户只对他们看到的东西以及软件提供的
功能感兴趣。同时，界面元素的创建具有很强的规律性，GIRL的一个重要目的就是：应用软件的开发者
只要给出静态界面构成的描述，就可以把一个复杂的、由多个构件构成的界面元素作为一个整体，进行
操作。在这个方面，Motif附带的应用程序UIL做出了一个很好的榜样。
<p>Motif的UIL的功能的局限性，限制了它的应用范围。UIL除了帮助应用程序创建静态界面之外，没有
其他的功能。可是，应用程序还可以通过创建子程序的手段创建界面，虽然比UIL麻烦一些。对于作为
一个整体的组合界面，应用程序往往还需要：
<ul>
<li>访问组合界面元素中某个构件的数据；
<li>保持组合界面元素中构件数据之间的预定义的相互关系；
</ul>
<p>只有对上述功能提供良好的支持，才能把大大地提高开发效率。真正发挥自动构造组合界面元素的优
势。否则，应用程序仍然需要深入组合界面元素内部，从而使开发工作复杂化、降低了模块的重用性。
<p>GIRL必须完成的另一项重要任务就是定义数据之间的约束关系，并自动地维护、保持这个关系。
<h2>3。设计GIRL必须面对的主要问题</h2>
<p>经过了上述分析，已经明确了GIRL需要完成的任务。那就是以描述的方式，描述组合界面对象的构成、
数据约束关系，并且给出统一的定义方式，遮蔽组合对象的构成和约束关系的细节。
<h3>3.1。应用方式问题</h3>
<p>GIRL是一种面向比较复杂的应用程序的独立语言。以描述的方式不可能实现软件的所有功能，GIRL
必须可C/C++语言分工合作，由GIRL完成界面的定义工作，由C/C++完成数据的具体处理任务。也就是说，
GIRL必须可以和C/C++代码进行连接，从而构成整个应用程序。同时，类似与C/C++，为了提高开发效率，
必须允许构件的模块化，即GIRL模块的分别编译。在当前的设计中，应用程序主要按照如下方式使用
GIRL：
<ul>
<li>编写GIRL源代码；
<li>编写与GIRL相连接的C/C++代码；
<li>利用GIRL编译器（命名为girlc）把GIRL源代码编译成C/C++代码（这样作有两个好处：可以和C/C++
十分容易地进行连接；可以大大地降低GIRL编译器的复杂度。）
<li>利用C/C++编译器生成目标代码，并且连接构成可执行应用程序或者静态、动态连接库。
</ul>
允许生成静态、动态连接库，一则是为了便于模块的重用，二则有助于实现Plug-in功能。
<h3>3.2。模块化问题</h3>
<p>所谓的模块化问题，实际上包括：在不同的GIRL模块中定义的对象如何相互访问、C/C++程序如何
访问GIRL模块中定义的对象两个问题。C/C++语言为我们提供了一个良好的解决方案。
<p>C/C++把对对象的说明和定义明确地分开。同一个对象可以在任何一个目标文件中进行说明，但是
任何一个对象却只能在一个目标文件中定义。
<p>由于每个目标文件都含有它所需要的对象的说明，因此可以准确无误地使用其它目标文件定义的
对象。对对象的说明仅仅是告知编译器对象的类型，编译器将不会因为说明而生成任何代码。因此不会
导致代码的浪费。
<p>由于只有一个目标文件含有对象的定义，因此不会出现多次定义同一对象而可能导致的冲突。编译器
只对象的定义生成相应的代码。
<p>根据对象的说明和定义的上述区别，编程者就可以把说明写入头文件，在每个需要说明的源文件中
引入给定头文件；把定义写入源文件。而后再把每个源文件编译成目标文件。最后，在连接的时刻检测
不同目标文件中是否重复地定义了对象。如果没有冲突，就生成可执行文件。
<p>GIRL的模块化采用了与C/C++完全类似的方式。关键是对每种对象给出对象的说明、对象的定义两种
方式。对象的说明含有的信息越少越好，但必须使得使用对象的其他对象可以正确地使用对象。对象的
定义则必须含有对象的全部细节。
<p>C/C++还提供了一些库函数以支持Plug-in功能。在不同的平台上，库函数界面有所不同。对于linux
来说，主要是通过库函数：dlopen、dlerror、dlsym、dlclose四个函数来实现的。GIRL支持Plug-in的
方式和C/C++的方式完全类似，详情暂略。
<h3>3.3。描述方式问题</h3>
<p>GIRL定义的核心对象是组合构件类。组合构件类应当含有如下信息：
<ul>
<li>组合构件类的类层次关系，也就是组合构件类的基类是什么。
<li>组合构件类对外提供的访问服务有那些。
<li>组合构件类作为父窗口，含有那些子构件，它们和整个组合构件类的关系是什么，是如何组合在一起的。
<li>在组合构件类的内部，子构件之间的数据约束关系是什么。
</ul>
<p>为了很好地完成上述任务，GIRL构造的专用的说明语言。
<p>GIRL中的构件类的成员可以由四种成分构成，它们分别是：数据储存槽（dataslot）、数据接收槽
（receiver）、信号连接槽（signallink）、私有数据空间。
<ul>
<li>数据储存槽可以储存<strong>一个</strong>GIRL允许的任意类型的数据。数据储存槽与普通
数据成员的不同之处在于：组合构件类中相同类型的数据储存槽可以相互连接（即永远具有相同的值）。
此外，数据储存槽还可以和数据接收槽进行连接。子类不能重新定义、删除基类定义的数据储存槽。
<li>数据接收槽可以包含一个接收函数、一个读出函数。数据接收槽接收的数据的类型是确定的。数据
接收槽之间可以相互连接（即永远按照相同的顺序接收到相同的数据）。此外，数据接收槽还可以和
数据储存槽相连接。子类不能重新定义、删除基类定义的数据接收槽。
<p>从某种意义上说，数据储存槽是数据接收槽的一种特例。数据储存槽是仅仅能够储存一个数据的
储存单元。而数据接收槽则可以储存复杂的数据结构，并在储存和读出的过程中进行特定的处理。
<li>信号连接槽类似与C++中的虚函数。信号连接槽可以和任何预定义或者自定义信号进行连接。预
定义信号主要有：对象创建信号、对象设置信号、对象删除信号、X Window事件信号等等。信号连接槽
必须给出一个响应函数。在指定的信号出现的时候调用该函数。在子类中可以重新定义响应函数，但
不能重新定义相关信号。
<li>在GIRL源文件中，不涉及私有数据。私有数据与类界面没有关系，可以在运行时由C/C++程序来处理。
</ul>
<p>数据储存槽、数据接收槽可以接收的数据可能有：整数、浮点数、字符串、颜色、光标、字体、构件。
那么，在GIRL中就必须允许定义这几类数据。此外，还可以定义由上述数据组合起来的组合结构。
<p>综上所述，在GIRL中可以定义的对象类型有：整数对象、浮点数对象、字符串对象、颜色对象、
光标对象、字体对象、构件类。GIRL必须分别为这些对象提供说明和定义的手段。此外，类似与
C/C++，GIRL允许定义类型。类型只有定义形式，没有说明形式。类型可以在多个模块中定义，这是因为
类型仅仅告知编译器组合数据的结构，而不生成任何代码。
<h3>3.4。约束定义问题</h3>
<p>GIRL要解决的一个重要问题就是确定组合构件类内部的数据约束。
<p>通过考察可以发现，对于某些构件来说，有必要从其子构件中“继承”某些数据或功能。比如说对话框，
常见的方式是在创建对话框之后，为了获得或设置对话框中控制的数据，就必须访问对话框中的控制。
这样，除非我们单独定义一个类，并且在类的界面中给出访问特定控制的函数或数据成员，否则就不能
把对话框看作一个对象整体。然而，这样做通常是相当麻烦的。如果提供了数据约束手段，把组合构件中的
某个数据成员或者访问函数与子构件相应的数据成员、访问函数统一起来，那么就可以轻易地实现单一的
类界面，再也没有必要直接访问子构件了。
<p>数据约束的另一大好处是简化数据相关关系的维护。比如说：某个控制的背景颜色必须和另一个控制
的背景颜色相同；某个控制中储存的整数值必须小于另一个控制中储存的整数值。
<p>在GIRL的设计中，提供数据储存槽、数据接收槽的目的就是为了支持数据约束的功能。应用程序只有
间接地访问数据储存槽、数据接收槽（通过数据储存槽访问函数、数据接收槽的接收、读出函数），才能
给系统以维护约束关系的机会。
<p>可能存在的数据约束有：
<ul>
<li>任何数据类型的数据的相等；
<li>整数的算术关系；
<li>浮点数的算术关系；
<li>字符串的比较关系、连接关系；
</ul>
<p>在上述关系中，应用范围最广泛的、最容易实现的是相等关系。在GIRL中，连接就是认定数据相等的
手段。连接可以在数据储存槽与数据储存槽之间、数据连接槽与数据连接槽之间、数据储存槽和数据
连接槽之间进行。
<p>在本设计中，没有给出说明算术整数关系的表述方式。如果引入算术整数关系，那么只能适用于数据
储存槽。需要指出的是算术整数关系的维护比较复杂，必须区分连接与被连接的区别，
<p>例1：对于关系X>=Y。其中X、Y都是整数类型数据储存槽。考虑如下情况：<ul>
<li>如果向X发送了比Y小的数据，那么究竟是拒绝接收X还是修改Y（如何修改）以保持上述关系？
<li>如果向Y发送了比X小的数据，那么究竟是拒绝接收Y还是修改X（如何修改）以保持上述关系？
</ul>
<p>例2：对于关系X=Y+1。其中X、Y都是整数类型数据储存槽。考虑如下情况：<ul>
<li>如果向X发送了使上述关系不成立的值，究竟是拒绝接收X还是修改Y以保持上述关系？
<li>如果向Y发送了使上述关系不成立的值，究竟是拒绝接收Y还是修改X以保持上述关系？
</ul>
<p>例3：对于关系X=Y/3。除了前面需要考虑的情况之外，还有：如果X被修改的话，事实上Y可能的值有3个。
如果处理这种情况？
<p>不难看出，一旦允许出现算术关系，可能导致为了维护数据约束关系而必须解方程组的情况。为此，GIRL
没有支持这种功能。
<p>浮点数的算术关系类似与整数的算术关系。此外，还必须考虑浮点数计算的误差问题。
<p>字符串的比较关系、连接关系类似于算术整数关系。但事实上字符串的比较关系、连接关系的应用很少，
而且效率很低。如果必须应用的话，由构件或应用程序用C/C++来实现往往效率更高一些。因此，GIRL没有
支持这种功能。
<h2>4。设计细节</h2>
<p>给出前面描述的目的是说明为什么要以一种相当特别的方式定义GIRL。事实上，GIRL与常见的GUI Tool
 Kit的表述方式有很大的不同。
<p>GIRL的设计分以下几个部分：<ul>
<li><a href="application.html">应用程序服务函数</a>；
<li><a href="module.html">GIRL对模块的支持</a>；
<li><a href="comment.html">GIRL源文件中的注释和宏替换</a>；
<li><a href="typedef.html">GIRL的类型定义</a>；
<li><a href="signal.html">GIRL信号</a>；
<li>对GIRL对象的支持：<ul>
<li><a href="declare.html">对GIRL对象的说明</a>；
<li><a href="define.html">对GIRL对象的定义</a>；
<li><a href="access.html">在C/C++中访问GIRL对象</a>。
<li><a href="widget.html">关于GIRL构件</a>；
</ul>
<li><a href="accelerator.html">GIRL对加速键的支持</a>；
<li><a href="usegirlc.html">使用GIRL编译器girlc</a>；
<li><a href="prewidget.html">GIRL的预定义构件</a>。
</ul>
<h2>5。对某些设计决策的说明</h2>
<h3>5.1。为什么GIRL自行实现类机制，而不是利用C/C++的类机制？</h3>
<p>使用自行实现的类机制主要好处有：<ul>
<li>可以和GIRL源文件完美地结合；
<li>可以高效地实现数据储存槽、数据连接槽的连接；
<li>所有的构件，包括预定义构件在内都是按照同一种方式构造的。这就使得对GIRL的扩展变得十分简便。
</ul>
<h3>5.2。为什么GIRL不对数据储存槽采用算术约束？</h3>
<p>这是因为一旦使用了算术约束，将导致需要大量运算的解线性代数方程组的工作，大大地降低了运行效率。
此外，即使未来需要添加算术约束，也可以在兼容现有语法的前提下，添加新语句实现算术约束。
<h2>6。最后的说明</h2>
<h3>6.1。发布</h3>
<p>GIRL的库函数将按照库通用公共许可证（LGPL）发布。GIRL的编译器girlc及其他工具程序将按照
通用公共许可证（GPL）发布。
<h3>6.2。关于本设计方案</h3>
<p>由于本设计方案仍然是草案，为了维护作者的名誉，请不要在未与作者商议的情况下发布本设计方案。
<p>本设计方案将根据讨论的情况进行适当的修改，作者Charles保留修改权。在基本定稿之后即开始开发
工作。在开发工作进行的过程中，可能还会对设计的某些细节进行修改，但是GIRL的设计思想将不会发生
变化。
<h3>6.3。关于交流和讨论</h3>
<p>本人欢迎任何形式的，有关GIRL设计的建议与提问。由于条件的限制，最便捷的方式是发送电子邮件到
<a href="mailto:blazing@263.net">这里</a>。所有有价值的建议，都将在本主页更新中独立地给出。
<p>如果您需要本主页的压缩包，可以通过电子邮件和本人联系，以便于离线浏览。
<hr>
<p align=center>对于您对GIRL的关心表示感谢
<p align=center>欢迎您参加对GIRL设计方案的讨论
<p align=center>欢迎您参加实现GIRL的工作
<p align=right>Charles 1999.9
</body>
</html>
