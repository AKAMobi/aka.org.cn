目  录
------
第一部分  基础知识
  一. 硬盘结构简介
  二. Boot Sector 结构简介
  三. 系统启动过程简介
第二部分  SmartBootManager 技术资料
  一. 简  介
  二. 程序简介
                       第一部分  基础知识

一. 硬盘结构简介

  1. 硬盘参数释疑

    到目前为止, 人们常说的硬盘参数还是古老的 CHS (Cylinder/
Head/Sector)参数. 那么为什么要使用这些参数, 它们的意义是什么?
它们的取值范围是什么?
    很久以前, 硬盘的容量还非常小的时候, 人们采用与软盘类似的结
构生产硬盘. 也就是硬盘盘片的每一条磁道都具有相同的扇区数. 由此
产生了所谓的3D参数 (Disk Geometry). 既磁头数(Heads), 柱面数
(Cylinders), 扇区数(Sectors per track),以及相应的寻址方式.

    其中:

    磁头数(Heads) 表示硬盘总共有几个磁头,也就是有几面盘片, 最大
为 256 (用 8 个二进制位存储);
    柱面数(Cylinders) 表示硬盘每一面盘片上有几条磁道, 最大为 1024
(用 10 个二进制位存储);
    扇区数(Sectors per track) 表示每一条磁道上有几个扇区, 最大为
63 (用 6 个二进制位存储).
    每个扇区一般是 512个字节, 理论上讲这不是必须的, 但好象没有取
别的值的.

    所以磁盘最大容量为:

    256 * 1024 * 63 * 512 / 1048576 = 8064 GB ( 1M = 1048576 Bytes )
或硬盘厂商常用的单位:
    256 * 1024 * 63 * 512 / 1000000 = 8455 GB ( 1M = 1000000 Bytes )

    在 CHS 寻址方式中, 磁头, 柱面, 扇区的取值范围分别为 0 到 Heads-1,
 0 到 Cylinders-1, 1 到 Sectors per track (注意是从 1 开始).
    在 CHS 寻址方式中, 有以下几种尺寸单位:
    扇区 (Sector)  = 512 字节 (一般情况下)
    磁道 (Track)   = (Sectors per track) 扇区
    柱面 (Cylinder)= (Sectors per track) * Heads 扇区

  2. 基本 Int 13H 调用简介

    BIOS Int 13H 调用是 BIOS 提供的磁盘基本输入输出中断调用, 它可以
完成磁盘(包括硬盘和软盘)的复位, 读写, 校验, 定位, 诊断, 格式化等功能.
它使用的就是 CHS 寻址方式, 因此最大识能访问 8 GB 左右的硬盘 ( 本文中
如不作特殊说明, 均以 1M = 1048576 字节为单位).


  3. 现代硬盘结构简介

    在老式硬盘中, 由于每个磁道的扇区数相等, 所以外道的记录密度要远低
于内道, 因此会浪费很多磁盘空间 (与软盘一样). 为了解决这一问题, 进一
步提高硬盘容量, 人们改用等密度结构生产硬盘. 也就是说, 外圈磁道的扇区
比内圈磁道多. 采用这种结构后, 硬盘不再具有实际的3D参数, 寻址方式也改
为线性寻址, 即以扇区为单位进行寻址.
    为了与使用3D寻址的老软件兼容 (如使用BIOS Int13H接口的软件), 在硬
盘控制器内部安装了一个地址翻译器, 由它负责将老式3D参数翻译成新的线性
参数. 这也是为什么现在硬盘的3D参数可以有多种选择的原因 (不同的工作模
式, 对应不同的3D参数, 如 LBA, LARGE, NORMAL).

  4. 扩展 Int 13H 简介

    虽然现代硬盘都已经采用了线性寻址, 但是由于基本 Int 13H 的制约, 使
用 BIOS Int 13H 接口的程序, 如 DOS 等还只能访问 8 G 以内的硬盘空间.
为了打破这一限制, Microsoft 等几家公司制定了扩展 Int 13H 标准
(Extended Int13H), 采用线性寻址方式存取硬盘, 所以突破了 8 G 的限制,
而且还加入了对可拆卸介质 (如活动硬盘) 的支持.
    (http://www.phoenix.com/products/specs.html)
二. Boot Sector 结构简介


  1. Boot Sector 的组成

    Boot Sector 也就是硬盘的第一个扇区, 它由 MBR (Master Boot Record),
DPT (Disk Partition Table) 和 Boot Record ID  三部分组成.

    MBR 又称作主引导记录,占用 Boot Sector 的前 446 个字节 ( 0 to 0x1BD ),
存放系统主引导程序 (它负责从活动分区中装载并运行系统引导程序).
    DPT 即主分区表占用 64 个字节 (0x1BE to 0x1FD), 记录了磁盘的基本分区
信息. 主分区表分为四个分区项, 每项 16 字节, 分别记录了每个主分区的信息
(因此最多可以有四个主分区).
    Boot Record ID 即引导区标记占用两个字节 (0x1FE and 0x1FF), 对于合法
引导区, 它等于 0xAA55, 这是判别引导区是否合法的标志.
    Boot Sector 的具体结构如下图所示:

      0000  |------------------------------------------------|
            |                                                |
            |                                                |
            |             Master Boot Record                 |
            |                                                |
            |                                                |
            |             主引导记录(446字节)                |
            |                                                |
            |                                                |
            |                                                |
      01BD  |                                                |
      01BE  |------------------------------------------------|
            |                                                |
      01CD  |             分区信息  1(16字节)                |
      01CE  |------------------------------------------------|
            |                                                |
      01DD  |             分区信息  2(16字节)                |
      01DE  |------------------------------------------------|
            |                                                |
      01ED  |             分区信息  3(16字节)                |
      01EE  |------------------------------------------------|
            |                                                |
      01FD  |             分区信息  4(16字节)                |
            |------------------------------------------------|
            | 01FE                | 01FF                     |
            |         55          |           AA             |
            |------------------------------------------------|

  2. 分区表结构简介


    分区表由四个分区项构成, 每一项的结构如下:

    BYTE State       : 分区状态, 0 = 未激活, 0x80 = 激活 (注意此项)
    BYTE StartHead   : 分区起始磁头号
    WORD StartSC     : 分区起始扇区和柱面号, 底字节的低6位为扇区号,
                     高2位为柱面号的第 9,10 位, 高字节为柱面号的低 8 位
    BYTE Type        : 分区类型, 如 0x0B = FAT32, 0x83 = Linux 等,
                     00 表示此项未用
    BYTE EndHead     : 分区结束磁头号
    WORD EndSC       : 分区结束扇区和柱面号, 定义同前
    DWORD Relative   : 在线性寻址方式下的分区相对扇区地址
                       (对于基本分区即为绝对地址)
    DWORD Sectors    : 分区大小 (总扇区数)

    注意: 在 DOS / Windows 系统下, 基本分区必须以柱面为单位划分
( Sectors * Heads 个扇区), 如对于 CHS 为 764/256/63 的硬盘, 分区的
最小尺寸为  256 * 63 * 512 / 1048576 = 7.875 MB.
    由于硬盘的第一个扇区已经被引导扇区占用, 所以一般来说, 硬盘第一
个磁道(0头0道)的其余 62 个扇区是不会被分区占用的. 某些分区软件甚至
将第一个柱面全部空出来.

  3. 扩展分区简介

    由于主分区表中只能分四个分区, 无法满足需求, 因此设计了一种扩展
分区格式. 基本上说, 扩展分区的信息是以链表形式存放的, 但也有一些特
别的地方.
    首先, 主分区表中要有一个基本扩展分区项, 所有扩展分区都隶属于它,
也就是说其他所有扩展分区的空间都必须包括在这个基本扩展分区中. 对于
DOS / Windows 来说, 扩展分区的类型为 0x05 或 0x0F (LBA模式).
    除基本扩展分区以外的其他所有扩展分区则以链表的形式级联存放, 后
一个扩展分区的数据项记录在前一个扩展分区的分区表中, 但两个扩展分区
的空间并不重叠.
    扩展分区类似于一个完整的硬盘, 必须进一步分区才能使用. 但每个扩
展分区中只能存在一个其他分区. 此分区在 DOS/Windows 环境中即为逻辑盘.
因此每一个扩展分区的分区表 (同样存储在扩展分区的第一个扇区中)中最多
只能有两个分区数据项(包括下一个扩展分区的数据项).
    扩展分区和逻辑盘的示意图如下:

  |-----------------------|             --------
  | 主扩展分区(/dev/hda2) |                    ^
  |-----------------------|                    |
  |  扩  展  |  分区项 1  |--\                 |
  |          |------------|  |                 |
  |  分区表  |  分区项 2  |--+--\              |
  |-----------------------|  |  |              |
  |                       |  |  |              |
  | 逻辑盘 1 (/dev/hda5)  |<-/  |              |
  |                       |     |              |
  |-----------------------|     |             主
  |      扩展分区 2       |<----/
  |-----------------------|                   扩
  |  扩  展  |  分区项 1  |--\
  |          |------------|  |                展
  |  分区表  |  分区项 2  |--+--\
  |-----------------------|  |  |             分
  |                       |  |  |
  | 逻辑盘 2 (/dev/hda6)  |<-/  |             区
  |                       |     |              |
  |-----------------------|     |              |
  |      扩展分区 3       |<----/              |
  |-----------------------|                    |
  |  扩  展  |  分区项 1  |--\                 |
  |          |------------|  |                 |
  |  分区表  |  分区项 2  |  |                 |
  |-----------------------|  |                 |
  |                       |  |                 |
  | 逻辑盘 3 (/dev/hda7)  |<-/                 |
  |                       |                    |
  |-----------------------|            ---------
注意, 以上所有扩展分区表中的第二个分区项(指向下一个扩展分区)的相对
扇区地址均相对于主扩展分区, 而不是前一个扩展分区.
三. 系统启动过程简介

    系统启动过程主要由一下几步组成(以硬盘启动为例):

    1. 开机 :-)
    2. BIOS 加电自检 ( Power On Self Test -- POST )
       内存地址为 0ffff:0000
    3. 将硬盘第一个扇区 (0头0道1扇区, 也就是Boot Sector)
       读入内存地址 0000:7c00 处.
    4. 检查 (WORD) 0000:7dfe 是否等于 0xaa55, 若不等于
       则转去尝试其他启动介质, 如果没有其他启动介质则显示
       "No ROM BASIC" 然后死机.
    5. 跳转到 0000:7c00 处执行 MBR 中的程序.
    6. MBR 首先将自己复制到 0000:0600 处, 然后继续执行.
    7. 在主分区表中搜索标志为活动的分区. 如果发现没有活动
       分区或有不止一个活动分区, 则停止.
    8. 将活动分区的第一个扇区读入内存地址 0000:7c00 处.
    9. 检查 (WORD) 0000:7dfe 是否等于 0xaa55, 若不等于则
       显示 "Missing Operating System" 然后停止, 或尝试
       软盘启动.
    10. 跳转到 0000:7c00 处继续执行特定系统的启动程序.
    11. 启动系统 ...

    以上步骤中 2,3,4,5 步是由 BIOS 的引导程序完成. 6,7,8,9,10
步由MBR中的引导程序完成.

    一般多系统引导程序 (如 SmartBootManager, BootStar, PQBoot 等)
都是将标准主引导记录替换成自己的引导程序, 在运行系统启动程序
之前让用户选择要启动的分区.
    而某些系统自带的多系统引导程序 (如 lilo, NT Loader 等)
则可以将自己的引导程序放在系统所处分区的第一个扇区中, 在 Linux
中即为 SuperBlock (其实 SuperBlock 是两个扇区).

    注: 以上各步骤中使用的是标准 MBR, 其他多系统引导程序的引导
过程与此不同.
            第二部分 SmartBootManager 技术资料
一. 简  介
  1. SmartBootManager 是什么?
    SmartBootManager (简称 SBM) 是一个独立于任何操作系统的启动
管理器, 它可以让用户在启动计算机的时候选择要启动的分区(或软驱).
    与 OS/2 BootManager, System Commander, PQ-Boot 等不同的是,
SBM 的尺寸非常小, 可以安装在硬盘 0 磁道的隐含扇区中, 无需任何
分区和系统.
    SBM 不是 OS Loader, 它必须与 OS Loader 相配合才能启动操作
系统. 例如, 要启动 Linux 还必需安装 lilo (或其他类似软件),
DOS / Windows 9x / Windows NT 也有自己的 OS Loader.
  2. SBM 的特点
    除了以上所说的小巧以外, SBM 还具有许多特点, 如:
    * 友好的用户界面
    * 强大的口令保护功能
    * 自动搜索分区
    * 支持多硬盘, 可以引导逻辑分区
    * 支持软驱启动
    * 支持大硬盘(使用扩展 Int 13h)
    * 支持从逻辑分区上启动 DOS / Windows 9X 系统.
二. SBM 程序简介
  1. 源文件简介
    SBM 的所有核心程序都用 nasm 写成, 为了方便编程, 将主程序分成了
几个不同功能的模块:
    ui.asm       用户界面模块, 完成窗口绘制, 字符串输入等功能
    hd_io.asm    磁盘 IO 模块, 负责访问磁盘驱动器
    knl.asm      核心模块, 主要完成分区搜索, 分区启动等功能
    utils.asm    实用函数模块, 包括数字<->字符串转换等函数
    main.asm     主程序
    loader.asm   调用程序, 用以替换标准 MBR, 负责装载主程序
    tempdata.asm 程序使用的临时变量和缓冲区
    theme-us.asm 英文界面数据
    theme-zh.asm 中文界面数据
  2. NASM 简介
    * NASM Is Case-Sensitive
    * NASM Requires Square Brackets For Memory References

      foo equ 5
      bar dw  6
    In MASM:
      mov ax, foo
      mov ax, bar
    In NASM:
      mov ax, foo
      mov ax, [bar]
    * NASM Doesn't Store Variable Types
      NASM has no LODS, STOS, MOVS etc.
    * NASM Doesn't `ASSUME'
    * NASM Doesn't Support Memory Models
    * Floating-Point Differences
    * Other Differences