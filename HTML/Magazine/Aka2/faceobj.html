<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>软件、软件危机、软件工程</title>
</head>

<body>
<div align="center"><center>

<table border="0" width="630">
  <tr>
    <td bgcolor="#EEEDB7"><h1 align="center">面向对象的软件开发</h1>
    <h1 align="center"><font size="2"><a href="cover.html">[返回]</a></font></h1>
    <p align="right">原作：Linda M. Northrop<br>
    Software Engineering Institute<br>
    翻译：[AKA] waterbird </p>
    <h3>1 历史回顾 </h3>
    <p>　　针对日趋复杂的软件需求的挑战，软件业界发展出了面向对象(OO)的软件开发模式。目前作为针对“软件危机”的最佳对策，OO技术已经引起人们的普遍关注。最初被多数人看作只是一种不切实际的方法和满足一时好奇心的研究，现在得到了人们近乎狂热的欢迎。许多编程语言都推出了支持面向对象的新版本。大量的面向对象的开发方法被提出来。关于OO的会议、学术研讨班和课程极受欢迎。无数专业的学术期刊都为这一话题开辟了专门的版面。一些软件开发合同甚至也指明了必须使用OO的技术和语言。面向对象的软件开发对于90年代，就向是结构化的软件开发对于70年代那样让人着迷，而且OO的发展势头还在日益加速。 
    </p>
    <p>　　诸如“对象”和“对象的属性”这样的概念，可以一直追溯到1950年代初。它们首先出现于关于人工智能的早期著作中。然而，OO的实际发展却是始于1966年 
    (当年文化大革命在中国爆发) 。 当时Kisten Nygaard和Ole-Johan Dahl开发了具有更高级抽象机制的Simula语言。Simula提供了比子程序更高一级的抽象和封装；为仿真一个实际问题，引入了数据抽象和类的概念。 
    大约在同一时期，Alan Kay正在尤他大学的一台个人计算机上努力工作，他希望能在其上实现图形化和模拟仿真。尽管由于软硬件的限制，Kay的尝试没有成功，但他的这些想法并没有丢失。70年代初期，他加入了Palo 
    Alto研究中心(PARC)，再次将这些想法付诸实施。 </p>
    <p>　　在PARC,他所在的研究小组坚信计算机技术是改善人与人、人与机器之间通讯渠道的关键。在这信念的支持下，并吸取了Simula的类的概念，他们开发出Smalltalk语言；1972年PARC发布了Smalltalk的第一个版本。大约在此时，“面向对象”这一术语正式确定。Smalltalk被认为是第一个真正面向对象的语言。 
    Smalltalk 
    的目标是为了使软件设计能够以尽可能自动化的单元来进行。在Smalltalk中一切都是对象-----即某个类的实例。最初的Smalltalk的世界中，对象与名词紧紧相连。Smalltalk还支持一个高度交互式的开发环境和原型方法。这一原创性的工作开始并未发表，只是视为带浓厚试验性质的学术兴趣而已。 
    </p>
    <p>　　Smalltalk-80是PARC的一系列Smalltalk版本的总结，发布于1981年。1981年8月的&lt;&lt;BYTE&gt;&gt;杂志公布了Smalltalk开发组的重要结果。在这期杂志的封面图上，一个热气球正从一个孤岛上冉冉升起来，标志着PARC的面向对象思想的启航。该是向软件开发界公开发表的时候了。起初，影响只是渐进式的，但很快就跃升到火爆的程度。热气球确实启航了，而且影响深远。早期Smalltalk关于开发环境的研究导致了后来的一系列进展：窗口（window），图标（icon）,鼠标(mouse)和下拉式window环境。Smalltalk语言还影响了８０年代早期和中期的面向对象的语言，如：Object-C(1986), 
    C++(1986), Self(1987),Eiffl(1987),Flavors(1986). 
    面向对象的应用领域也被进一步拓宽。对象不再仅仅与名词相联系，还包括事件和过程。1980 
    Grady Booch首先提出面向对象设计（OOD）的概念。然后其他人紧随其后，面向对象分析的技术开始公开发表。1985年，第一个商用面向对象数据库问世。1990年代以来，面向对象的分析、测试、度量和管理等研究都得到长足发展。目前对象技术的前沿课题包括设计模式(design 
    patterns)、分布式对象系统和基于网络的对象应用等。 </p>
    <h3>2 动因 </h3>
    <p>　　为什么面向对象运动发展到了现在这样火暴的程度？部分是源于人们长久以来的一个希望：人们希望它，象以前其他的软件开发技术一样，能够满足软件开发对于生产效率、可靠性、易维护性、易管理等方面的更高、更快、更强的迫切需求。除此之外，还有许多原因都促使了它的流行。 
    </p>
    <p>　　面向对象的开发强调从问题域的概念到软件程序和界面的直接映射；心理学的研究也表明，把客观世界看成是许多对象更接近人类的自然思维方式。对象比函数更为稳定；软件需求的变动往往是功能相关的变动，而其功能的执行者----对象----通常不会有大的变动。另外，面向对象的开发也支持、鼓励软件工程实践中的信息隐藏、数据抽象和封装。在一个对象内部的修改被局部隔离。面向对象开发的软件易于修改、扩充和维护。 
    </p>
    <p>　　面向对象也被扩充应用于软件生命周期的各个阶段---从分析到编码。而且，面向对象的方法自然而然地支持快速原型法和RAD(Rapid 
    Application Development)。面向对象开发的使用鼓励重用，不仅软件的重用，还包括分析、设计的模型的重用。更进一步，OO技术还方便了软件的互换性，即，网络中一个节点上应用能够利用另一个节点上的资源。面向对象的开发还支持并发、层次和复杂等一些在目前的软件系统中常见的现象。今天我们常常会需要建造一些软件系统----不止是一黑盒应用。这些复杂系统通常包含由多个子系统组成的层次结构。面向对象的开发支持开放系统的建设；利用不同的应用来进行软件集成有了更大的柔性。最后，面向对象开发的使用可以减小开发复杂系统所面临的危险，主要是因为系统集成遍布软件生命周期的各个阶段。 
    </p>
    <h3>3 面向对象的建模 </h3>
    <p>　　面向对象的建模不仅仅是新的编程语言的汇总。它是一种新的思维方式，一种关于计算和信息结构化的新思维。面向对象的建模，把系统看做是相互协作的对象，这些对象是结构和行为的封装，都属于某个类，那些类具有某种层次化的结构。系统的所有功能通过对象之间相互发送消息来获得。面向对象的建模可以视为是一个包含以下元素的概念框架：抽象、封装、模块化、层次、分类、并行、稳定、可重用和可扩展性。 
    </p>
    <p>　　面向对象的建模的出现并不能算是一场计算革命。更恰当地讲，它是面向过程和严格数据驱动的软件开发方法的渐进演变结果。软件开发的新方法受到来自两个方面的推动：编程语言的发展和日趋复杂的问题域的需求驱动。尽管在实际中分析和设计在编程阶段之前进行，但从发展历史看却是编程语言的革新带来设计和分析技术的改变。同样，语言的演变也是对计算机体系的增强和需求的日益复杂的自然响应。 
    </p>
    <p>　　影响OO产生的诸多因素中，最重要的可能要算是编程方法的进步了。在过去的几十年中，编程语言中对抽象机制的支持已经发展到了一个较高的水平。这种抽象的进化从地址（机器语言）到名字（汇编语言），到表达式（第一代高级语言，如Fortran）,到控制（第二代高级语言，如Cobol），到过程和函数（第二代和早期第三代高级语言，如Pascal）,到模块和数据(晚期第三代高级语言，如modula),最后到对象（基于对象和面向对象的语言）。Smalltalk和其他面向对象语言的发展使得新的分析和设计的技术的实现成为可能。 
    </p>
    <p>　　这些新的OO的技术实际上是结构化和数据库方法的融合。OO的方法中，小范围内对面向数据流的关注，如偶合和聚合，也是很重要的。同样，对象内部的行为最终也需要面向过程的设计方法。数据库技术中的实体-关系（ER图）的数据建模思想也在 
    OO的方法中得以体现。 </p>
    <p>　　计算机硬件体系结构的进步，性能价格比的提高和硬件设计中对象概念的引入都对OO的发展产生了一定的影响。OO的程序通常要更加频繁地访问内存，需要更高的处理速度。他们需要并且也正在利用强大的计算机硬件功能。哲学和认知科学的层次和分类理论也促进了OO的产生和发展。最后，计算机系统不断增长的规模、复杂度和分布性都对OO技术起了或多或少的推动作用。 
    </p>
    <p>　　因为影响OO发展的因素很多，OO技术本身还未成熟，所以在思想和术语上有很多不同的提法。所有的OO语言并非生而平等，他们在术语、概念的运用上也各不相同。尽管也存在统一的趋势，但就如何进行面向对象的分析、设计而言还没有完全达成共识，更没有统一的符号来描述这些活动。（说明：UML正在朝这方向努力） 
    但是，OO的开发已经在以下领域被证明是成功的：空中交通管理、动画设计、银行、商业数据处理、命令和控制系统、CAD、CIM、数据库、专家系统、图象识别、数学分析、音乐合成、操作系统、过程控制、空间站软件、机器人、远程通讯、界面设计和VLSI设计。毫无疑问，OO技术的应用已经成为软件工业发展的主流。 
    </p>
    <h3>4 面向对象编程 </h3>
    <p>&lt;1&gt; 概念 </p>
    <p>　　在面向对象编程中，程序被看作是相互协作的对象集合，每个对象都是某个类的实例，所有的类构成一个通过继承关系相联系的层次结构。面向对象的语言常常具有以下特征：对象生成功能、消息传递机制、类和遗传机制。这些概念当然可以并且也已经在其他编程语言中单独出现，但只有在面向对象语言中，他们才共同出现，以一种独特的合作方式互相协作、互相补充。 
    </p>
    <p>过程化编程模式： 参数输入----- | 代 码 | ------结果输出 </p>
    <p>为实现某个功能，参数被传入某个处理过程，最后传回计算结果。 
    </p>
    <p>　 　| 对象------ 数据结构 面向对象编程模式： <br>
    界面 | 对象------ 和<br>
    　　 | 对象------ 操作 </p>
    <p>　　OOP中，功能是通过与对象的通讯获得的。对象可以被定义为一个封装了状态和行为的实体；或者说是数据结构（或属性）和操作。状态实际上是为执行行为而必须存于对象之中的数据、信息。对象的界面，也可称之为协议，是一组对象能够响应的消息的集合。 
    消息是对象通讯的方式，因而也是获得功能的方式。对象受到发给他的消息后，或者执行一个内部操作（有时成为方法或过程），或者再去调用其他对象的操作。所有对象都是类的实例。类是具有相同特点的对象的集合，或者也可以说，类是可用于产生对象的一个模版。对象响应一个消息而调用的方法，由接受该消息的对象自己决定。 
    类可以以一种层次结构来安排。在这个层次结构中，子类可以从比他高的超类中继承得到状态和方法。当对象接收到一个消息后，寻找相应的方法的过程将在从该对象的类开始，并在该类所处的层次结构中展开，最后，直到找着该方法，或者什么也没找到（将会报错）。在某些语言中，一个给定的类可以从不止一个超类中继承，称之为多继承。如果采用动态联编，继承就导致了多态性。多态性描述的是如下现象：如果几个子类都重新定义了超类的某个函数（都用相同的函数名），当消息被发送到一个子类对象时，在执行时该消息会由于子类确定的不同而被解释为不同的操作。 
    方法也可以被包括在超类的界面中被子类继承，而实际上并不去真正定义他。这样的超类也叫抽象类。抽象类不能被实例化，因此也就只能被用于产生子类。 
    </p>
    <p>&lt;2&gt; 语言 </p>
    <p>面向对象的语言包含4个基本的分支： </p>
    <p>1 基于Smalltalk的; 包括smalltalk的5个版本，以Smalltalk-80为代表。 </p>
    <p>2 基于C的; 包括 objective-C, C++, Java </p>
    <p>3 基于LISP的; 包括 Flavors, XLISP, LOOPS, CLOS </p>
    <p>4 基于PASCAL的。包括 Object Pascal, Turbo Pascal, Eiffel, Ada 95 </p>
    <p>　　Simula实际上是所有这些语言的老祖宗。在这些OO语言中，术语的命名和支持OO的能力都有不同程度的差别。 
    尽管Smalltalk-80不支持多继承，它仍被认为是最面向对象的语言(the 
    truest OO language)。</p>
    <p>　　在基于C的OO语言中，Object-C 是Brad Cox开发的，它带有一个丰富的类库，已经被成功用于大型系统的开发。C++是由贝尔实验室的Bjarne 
    Stroustrup写的。它将C语言中的STRUCT 扩展为 具有数据隐藏功能的CLASS。多态性通过虚函数(virtual 
    functions)来实现。C++ 2.0 支持多继承。在多数软件领域，尤其是Unix平台上，C++都是首选的面向对象编程语言。 
    同C和C++相类似的新一代基于Internet的面向对象语言Java是由Sun 
    microsystems研制的。它于1995年伴随着Internet的崛起而风靡一时。用Java写的applets可以嵌入HTML中被解释执行，这使它具备了跨平台特性。Java和Ada一样支持多线程和并发机制，又象C一样简单、便携。</p>
    <p>　　基于LISP的语言，多被用于知识表达和推理的应用中。其中CLOS(Common 
    LISP Object System)是面向对象LISP的标准版。</p>
    <p>　　在基于Pascal的语言中，Object Pascal是由Apple和Niklaus Wirth为Macintosh开发的,它的类库是MacApp。Turbo 
    Pascal 是Borland公司以Object Pascal为范本开发的。</p>
    <p>　　Eiffel由交互软件工程公司的Bertrand Meyer于1987年发布的。它的语法类似Ada,运行于Unix环境。Ada在1983年刚出来时并不支持继承和多态性，因而不是面向对象的。到了1995年，一个面向对象的Ada终于问世，这就是Ada 
    95。</p>
    <p>　　除了上述的面向对象的语言之外，还有一些语言被认为是基于对象(Object-based)的。它们是：Alphard, 
    CLU, Euclid, Gypsy, Mesa, Modula。</p>
    <h3>5 面向对象的软件工程 </h3>
    <p>生命周期 </p>
    <p>　　尽管面向对象的语言正在取得令人激动的进展，但我们都知道，编码并非是软件开发中的问题的主要来源。相比之下，需求和分析的问题更加普遍，而且它们的纠错代价更加昂贵。因此， 
    对OO开发技术的关注就不能仅仅集中在编码上面，更应集中关心软件工程的其他方面。OO方法在处理复杂系统的分析和设计、分析和设计的重用方面的应用前景也是非常可观。如果我们承认OO的软件开发不仅仅局限于编码活动，那么就必须采用一种全新的开发模式，包括新的软件生命周期。 
    目前最常见的生命周期是“瀑布”模型（结构化）。它是在60年代末“软件危机”后出现的第一个生命周期模型。如下所示。</p>
    <p>分析 ----- 设计 ----- 编码 ----- 测试 ------ 维护</p>
    <p>　　如图所示，瀑布式生命周期的开发过程是顺序行进的；活动流向基本是单向的。它假设开发者在开发初期对系统的了解足够清楚。不幸的是，任何软件开发活动都不可避免地要涉及大量迭代过程，无论你事先是否安排。好的设计人员指的是那些能同时在抽象的层面和具体的细节上进行工作的实践家。总的来说，瀑布式生命周期的缺点表现在三个方面：&lt;1&gt; 
    后期的变化、迭代、改动困难 &lt;2&gt; 不支持重用 &lt;3&gt; 
    没有一个联系各个阶段的统一模型。</p>
    <p>　　面向对象的方法从问题模型开始，然后就是识别对象、不断细化的过程。它从本质上就是迭代的和渐增的。在这里，快速原型和反馈环路是必需的标准结构。开发过程就是一次次的迭代反复过程。随着迭代的进行，系统的功能不断完善。这里，传统的开发模式中在分析、设计和编码等各个阶段之间的明显界限变得模糊起来。其原因是因为对象的概念弥漫了整个开发过程。对象和它们之间的关系成为分析、设计和编码等各个阶段的共同表达媒介。开发的重心从编码向分析偏移，从功能为中心向数据为中心偏移。而且，面向对象开发的迭代和无缝性使得重用变得更加自然。</p>
    <p>　　近来，为改善面向对象开发的可管理性，玻姆(Boehm,1988)提出了一个结合了宏观和微观视角(macro 
    &amp; microview)的螺旋开发模型。宏观包括3个阶段：1分析---发现和识别对象；2 
    设计---发明和设计对象；3 实施---创建和实现对象。每个宏观阶段都包含一些微观迭代活动。</p>
    <h3>6 OOA和OOD</h3>
    <p>　　由于面向对象的技术还比较新，目前存在许多种面向对象的分析和设计方法。面向对象的分析(OOA)建立于以前的信息建模技术的基础之上，可以定义为是一种以从问题域词汇中发现的类和对象的概念来考察需求的分析方法。OOA的结果是一系列从问题域导出的“黑箱”对象。OOA通常使用“剧情(scenarios)”来帮助确定基本的对象行为。一个剧情是发生在问题域的一个连续的活动序列。在对一个给定的问题域进行 
    OOA时，“框架”(Frameworks)的概念非常有用。框架是应用或应用子系统的骨架，包含一些具体或者抽象的类。或者说，框架是一个特定的层次结构，包含描述某一问题域的抽象父类。当下流行的所有的OOA方法的一个缺点就是他们都缺乏一种固定的模式(formality)。</p>
    <p>　　在面向对象的设计(OOD)阶段,注意的焦点从问题空间转移到了解空间。OOD是一种包含对所设计系统的逻辑的和物理的过程描述，以及系统的静态和动态模型的设计方法(Booch,1994)。</p>
    <p>　　在OOA和OOD中，都存在着对重用性的关注。目前，OO技术的研究人员们正在尝试定义“设计模式(design 
    patterns)”这一概念。它是一种可重用的“财富”，可以应用于不同的问题域。通常，设计模式指的是一种多次出现的设计结构或解决方案。如果对他们进行系统的归类，即可被重用，可以构成不同设计之间通信的基础。</p>
    <p>　　OOD技术实际上早于OOA技术而出现。目前在OOA和OOD已经很难画出一条清晰的界限。因此，下面的描述给出一些常用的OOA/OOD技术的（联合）概貌。</p>
    <p>　　Meyer 用语言作为表达设计的工具。(1988)</p>
    <p>　　Booch的OOD技术扩展了他以前在Ada方面的工作。他采用一种“反复综合(round-trip 
    gestalt)”的方法，包括以下过程：识别对象，识别对象的语义，识别对象之间的关系，进行实施，同时包含一系列迭代。Booch是最先使用类图，类分类图，类模板和对象图来描述OOD的人(1991)。</p>
    <p>　　Wrifs-Brock's的OOD技术是由职责代理来驱动的。类职责卡(Class 
    Responsibilities Cards)被用来记录负责特定功能的类。在确定了类及其职责之后，再进行更详细的关系分析和子系统的实施。(1990)</p>
    <p>　　Rumbaugh使用3种模型来描述一个系统：1 
    对象模型，描述系统中对象的静态结构；2 
    动态模型，描述系统状态随时间变化的情况；3 
    功能模型，描述系统中各个数据值的转变。对象图，状态转换图和数据流图分别被用于描述这3个模型。(1991)</p>
    <p>　　Coad和Yourdon采用以下的OOA步骤来确定一个多层OO模型（5个层次）：找出类和对象，识别结构和关系，确定主题，定义属性，定义服务。5个步骤分别对应模型的5个层次，即类和对象层，主题层，结构层，属性层和服务层。他们的OOD方法既是多层次的又是多方面的(multicomponent)。层次机构和OOA一样。多方面包括：问题域，人与人的交互，任务管理和数据管理。</p>
    <p>　　Ivar Jacobson 提出了Objectory方法(或Jacbson法)，一种他在瑞典Objective系统中开发的面向对象软件工程方法。Jacbson的方法特别强调了“Use 
    Case”的使用。 Use Case成为分析模型的基础，用交互图(Interaction 
    Diagram)进一步描述后就形成设计的模型。Use cases同时也驱动测试阶段的测试工作。到目前为止，Jacbson法是最为完整的工业方法。 
    （1992）</p>
    <p>　　以上所述的方法还有许多的变种，无法一一列出。近年来，随着各种方法的演变，它们之间也互相融合。1995年，Booch,Rumbaugh和Jacbson联手合作，提出了第一版的UML(Unified 
    Modelling Language),一体化建模语言。(目前已经成为OO建模语言的事实标准)</p>
    <h3>7 管理问题 </h3>
    <p>　　当组织向面向对象的开发技术转向时，支持软件开发的管理活动也必然要有所改变。承诺使用OO技术即意味要改变开发过程，资源和组织结构。(Goldberg 
    1995) OO开发的迭代、原型以及无缝性消除了传统开发模式不同阶段之间的界限。新的界限必须被重新确定。同时，一些软件测度的方法也不在适用了。“代码行数”LOC(Lines 
    of Code)绝对过时了。重用类的数目，继承层次的深度，类与类之间关系的数目，对象之间的耦合度，类的个数以及大小显得更有意义。在OO的软件测度方面的工作还是相当新的，但也已经有了一些参考文献。(Lorenz 
    1993)</p>
    <p>　　资源分配和人员配置都需要重新考虑。开发小组的规模逐步变小，擅长重用的专家开始吃香。重点应该放在重用而非LOC上。重用的真正实现需要一套全新的准则。在执行软件合同的同时，库和应用框架也必须建立起来。长期的投资策略，以及对维护这些可重用财富的承诺和过程，变的更加重要。</p>
    <p>　　至于软件质量保证，传统的测试活动仍是必须的，但它们的计时和定义必须有所改变。例如，将某个功能“走一遍”将牵涉到激活一个剧情(scenario),一系列对象互相作用，发送消息，实现某个特定功能。测试一个OO系统是另一个需要进一步研究的课题。发布一个稳定的原型需要不同与以往控制结构化开发的产品的配置管理。</p>
    <p>　　另一个管理方面要注意的问题是合适的工具支持。一个面向对象的开发环境是必须的。同时需要的还包括：一个类库浏览器，一个渐增型编译器，支持类和对象语义的调试器，对设计和分析活动的图形化支持和引用检查，配置管理和版本控制工具，以及一个象类库一样的数据库应用。</p>
    <p>　　除非面向对象开发的历史足以提供有关资源和消耗的数据，否则成本估算也是一个问题。计算公式中应该加入目前和未来的重用成本。最后，管理也必须明白在向面向对象方法转变的过程中要遇到的风险。如消息传递、消息传递的爆炸增长、动态内存分配和释放的代价。还有一些起步风险，如对合适的工具，开发战略的熟悉，以及适当的培训，类库的开发等。</p>
    <h3>8 向面向对象转变 </h3>
    <p>　　这个转变的时期可能相当长。培训是必须的。一个实验性质的向导项目也是有必要的。建议不要使用结构化和面向对象像结合的办法。越来越多的证据表明，成功需要完全的 
    OO解决方案. </p>
    <h3>9 未来</h3>
    <p>　　总的来说，面向对象的技术是以前的软件开发技术自然演进的成果，对许多应用领域的软件开发都极具前途。借用Maurice 
    Wilkes在他图灵奖颁奖仪式上的演讲的话：“对象是软件界从70年代以来最激动人心的革新之一。” 
    (1996) 
    然而，面向对象的开发并非是包医百病的灵丹妙药，其发展还远未成熟。可是尽管OO技术的未来还未确定，但在90年代初期的一些预言都已实现。(Winblad 
    1990) 
    类库和应用程序框架在市场上已经可用。应用和环境之间的透明信息存取业已实现。支持用户在应用之间通信的的环境以及面向对象的继承多媒体工具包正在涌现。随着经验的积累，OO的发展将日渐流行，OO技术也将日趋成熟。当然，OO技术也有可能为某种处理更高一级抽象的开发技术取代或融合。这些都只是猜想。虽然在不远的将来，谈论对象无疑会显得过时，但现在，还有许多的问题等着我们去付出真正的热情。</p>
    <p align="center"><a href="cover.html"><font size="2">[返回]</font></a></td>
  </tr>
</table>
</center></div>
</body>
</html>
